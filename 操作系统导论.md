[答案](https://github.com/joshuap233/Operating-Systems-Three-Easy-Pieces-NOTES)

# 虚拟化

## 进程

- **定义**
  - *非正式定义*：运行中的程序。
  - *正式定义*：是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。

- **时分共享和空分共享**
  - *时分共享*：允许资源由一个实体使用一小段时间，由另一个实体使用一小段时间。
  - *空分共享*：资源在空间上被划分给希望使用使用它的人。
- **机制和策略**
  - *机制*：一些低级方法或协议，实现了所需的功能。
  - *策略*：操作系统内做出某种决定的算法。

```c
struct context {
  int eip;
  int esp;
  int ebx;
  int ecx;
  int edx;
  int esi;
  int edi;
  int ebp;
};

enum proc_state { 
  UNUSED, 		// 未使用
  EMBRYO, 		// 初始化，在创建时的状态
  SLEEPING, 	// 休眠
  RUNNABLE, 	// 可运行
  RUNNING, 		// 运行
  ZOMBIE 			// 僵尸
};

struct proc {
  char *mem; 									// 进程内存开始位置
  uint sz;										// 进程内存大小
  char *kstack;								// 此进程的内核堆栈底部
  enum proc_state state; 			// 进程状态
  int pid;										// 进程id
  struct proc *parent;				// 父进程
  void *chan;									// 如果非零，在chan上休眠
  int killed;									// 如果非零，则已终止
  struct file *ofile[NOFILE];	// 打开的文件列表
  struct inode *cwd;					// 当前目录
  struct context context;			// 切换上下文
  struct trapframe *tf; 			// 陷阱框架
}
```

### 状态

- **运行**：在运行状态下，进程正在处理器上运行。意味着正在执行指令。
- **就绪**：在就绪状态下，进程已准备好运行，但由于某种原因，操作系统选择不在此时运行。
- **阻塞**：在阻塞状态下，一个进程执行了某种操作，直到发生其他事件时才会准备运行。
- **初始**：进程在创建时的状态。
- **最终状态**：已退出但尚未清理的状态，即僵尸状态。

### 进程API

```shell
./ch5/syscall
```

- **创建：fork()**

  - 父子进程都从 `forc()` 调用处返回，新创建的为子进程，原来的进程为父进程。

  - **子进程从父进程完全拷贝一份**，除了：子进程的 `fork()` 位置返回的是0，父进程的 `fork()` 位置返回的是子进程 `pid`。

- **等待：wait()**

  - 父进程可以调用 `wait()`，延迟自己的执行，等待子进程执行完毕。

- **执行：exec()**

  > 可以让子进程执行和父进程不同的程序。

  - 从可执行程序中加载代码和静态数据，并覆写自己的代码段【和静态数据】、堆、栈内存空间。
  - 参数通过 `argv` 传递程序。
  - 不创建新进程，把当前程序替换为不同的进程。

- **销毁**：强制销毁进程。

- **其他控制**：大多数操作系统提供某种方法来暂停进程。

- **状态**：运行了多长时间、出于什么状态。

### 机制：受限直接执行

> limit direct execution：让用户想运行的程序在CPU上运行之前，首先确保设置好硬件，以便在没有操作系统帮助的情况下限制进程可以执行的操作。

#### 解决的问题

1. 保证一个程序不做违规操作，并保证性能？
2. 如何将一个进程切换到另一个进程？

#### 操作受限

- **用户模式和内核模式**
  - *用户模式*：代码受到限制，如 `I/O` 操作。
  - *内核模式*：可以运行任何代码，操作系统跑在内核模式。

**协议有两个阶段**：

#### 进程间切换

进程切换的时机有两个：**系统调用** 和 **时钟中断**。

- **时钟中断**：时钟设备编程为每隔几毫秒发生一次中断，操作系统预先配置的调度策略运行，拿到CPU控制权。

- **上下文切换**：为当前正在执行的进程保存一些寄存器的值，这样可以确保最后执行从陷阱返回指令时，可以执行另一个进程。

  > 通用寄存器、程序计数器，以及当前正在运行的进程的内核栈指针。

  - **上下文切换成本**：不仅仅来自保存和恢复少量寄存器，还有CPU高速缓存、TLB、分之预测器和其他片上硬件中建立了大量状态。

##### 系统调用运行过程

- **启动**

  | 操作系统     | 硬件                       | 程序 |
  | ------------ | -------------------------- | ---- |
  | 初始化陷阱表 |                            |      |
  |              | 记住系统调用处理程序的地址 |      |

  > 在系统引导时，内核初始化陷阱表，并且CPU记住它的位置以供随后使用。内核通过特权指令来执行此操作。

- **运行**

  | 操作系统                                                     | 硬件                                                         | 程序                                                  |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------------------------------------------- |
  | 在进程列表上创建条目<br />为程序分配内存<br />将程序加载到内存中<br />根据 argv 设置程序栈<br />用寄存器/程序计数器填充内核栈<br />从陷阱返回 |                                                              |                                                       |
  |                                                              | 从内核栈恢复寄存器<br />转向用户模式<br />跳到 main          |                                                       |
  |                                                              |                                                              | 运行 main<br />……<br />调用系统调用<br />陷入操作系统 |
  |                                                              | 将寄存器保存到内核栈<br />转向内核模式<br />跳到陷阱处理程序 |                                                       |
  | 处理陷阱<br />做系统调用的工作<br />从陷阱返回               |                                                              |                                                       |
  |                                                              | 从内核栈恢复寄存器<br />转向用户模式<br />跳到陷阱之后的程序计数器 |                                                       |
  |                                                              |                                                              | ……<br />从main返回<br />陷入操作系统                  |
  | 释放进程的内存<br />将进程从进程列表中清除                   |                                                              |                                                       |

  > 运行进程时，在使用从陷阱返回指令开始执行进程之前，内核设置了一些内容。会将CPU切换到用户模式并开始运行该进程。当进程希望发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。该进程然后完成它的工作，并从main()返回。这通常会返回到一些存根代码，它将正确退出该程序（例如，通过调用exit()系统调用，这将陷入OS中）。此时，OS清理干净，任务完成了。

##### 时钟中断运行过程

- **启动**

  | 操作系统     | 硬件                                                   | 程序 |
  | ------------ | ------------------------------------------------------ | ---- |
  | 初始化陷阱表 | 记住以下地址：<br />系统调用处理程序<br />时钟处理程序 |      |
  | 启动时钟中断 |                                                        |      |
  |              | 启动时钟                                               |      |
  |              | 每隔 x ms 中断CPU                                      |      |

- **运行**

  | 操作系统                                                     | 硬件                                                         | 程序     |
  | ------------------------------------------------------------ | ------------------------------------------------------------ | -------- |
  |                                                              |                                                              | 进程 A…… |
  |                                                              | 时钟中断<br />将寄存器（A）保存到内核栈（A）<br />转向内核模式<br />跳到陷阱处理程序 |          |
  | 处理陷阱<br />调用 switch()例程<br />将寄存器（A）保存到进程结构（A）<br />将进程结构（B）恢复到寄存器（B）<br />从陷阱返回（进入 B） |                                                              |          |
  |                                                              | 从内核栈（B）恢复寄存器（B）<br />转向用户模式<br />跳到 B 的程序计数器 |          |
  |                                                              |                                                              | 进程 B…… |

### 策略

- **公式**

$$
T(周转时间) = T(完成时间) - T(到达时间)
$$

$$
T(响应时间) = T(首次运行时间) - T(到达时间)
$$



#### 先进先出：FIFO

短任务在长任务之后，会导致平均周转时间较高。

#### 最短任务优先：SJF

在任务同时到达时可行，但任务往往不是同时到达的。

#### 最短完成时间优先：STCF

每当新工作进入系统时，确定剩余工作和新工作中谁的剩余时间最少。但是响应时间不好。

#### 轮转：RR

响应时间较好，但周转时间很差。

#### 多级反馈队列：MLFQ

> 当对进程一无所知时，如何构建调度程序？

- **规则1**：如果A的优先级 > B的优先级，运行A（不运行B）。
- **规则2**：如果A的优先级 = B的优先级，轮转运行A和B。
- **规则3**：工作进入系统时，放在最高优先级。
- **规则4**：一旦工作用完了其在某一层中的时间配额【无论中间放弃了多少次CPU】，就降低其优先级。
- **规则5**：经过一段时间，就将系统中所有工作重新加入最高优先级队列。

## 内存
[答案](https://wenku.baidu.com/view/c8644769757f5acfa1c7aa00b52acfc789eb9fcb.html)

₀      ₁          ₂     ₃       ₄    ₅     ₆      ₇      ₈        ₉

# 计算机概要与技术

## 八个伟大思想

- **面向摩尔定律的设计**：预测项目完成时的工艺水平。
- **使用抽象简化设计**：层次间不关注细节。
- **加速大概率事件**：对大概率会发生的事件进行提速。
- **通过并行提高性能**
- **通过流水线提高性能**
- **通过预测提高性能**：通过预测的方式提前开始某些操作。
- **存储器层次**：快且昂贵的作为存储器顶层、慢且便宜的作为存储器底层。
- **通过冗余提高可靠性**：冗余部件或数据。

## 程序概念

- **系统软件**：提供常用服务的软件。包括操作系统、编译程序、加载程序和汇编程序等。
- **操作系统**：用户程序和硬件之间的接口。
  - 处理输入输出。
  - 分配外存和内存。
  - 提供应用间共享的计算机资源。
- **高级程序语言**：可以由编译器转换为汇编语言。
  - 语言表达更自然。
  - 提高生产率。
  - 提高移植性。
- **编译程序【编译器】**：将高级语言翻译成汇编语言。
- **汇编程序**：将指令由助记符翻译成二进制形式。
  - *汇编语言*：用助记符形式表示的语言。
  - *机器语言*：以二进制形式表示的机器指令。

## 硬件

> - 集成电路：也叫芯片，将几十至几百万个晶体管连接起来的设备。
> - 指令集体系【体系结构】：是低层次软件和硬件之间的抽象接口，包含了指令、寄存器、存储访问、和I/O等。
>   - 应用二进制接口：用户部分指令和应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。
>   - 实现：遵循体系结构抽象的硬件。

- **输入设备**：将数据写入存储器。

  > 键盘、鼠标。

- **输出设备**：从内存中读出数据。

  - *显示器*
    - **液晶显示**【LCD】：一种显示技术，**控制光的传输，非光源**。用液体聚合物薄层的带电或者不带电来传输或组织光线的传输。
    - **动态矩阵显示**：液晶显示技术，使用晶体管控制单个像素上光纤的传输。
    - **彩色动态矩阵**：每个像素有红绿蓝3类晶体管开关。
      - **位图**：图像由像素矩阵组成，可表示成二进制位的矩阵。
      - **分辨率**：矩阵的大小。如 1024 * 768。
      - **帧缓冲区**：保存位图，以刷新频率输出到显示设备。
    - **像素**：图像元素的最小单元。每个像素24位。
  - *触摸屏*：平板采取电容感应实现。

- **存储器**

  - **主存储器**：易失性存储器，仅在加电时保存数据。
    - **缓存**：处理器内使用，小而快的存储器，作为内存的缓冲。
      - **SRAM**：static random access memory，**静态随机访问存储器**，集成电路式，比
    - **内存**：程序运行时的存储空间，同时存储程序运行时所需数据。
      - **DRAM**：dynamic random access memory，**动态随机访问存储器**，集成电路式，可随机访问任何地址，时间一样。
  - **二级存储器**：非易失性存储器，在掉电时仍保持数据。
    - **磁盘**：硬盘，以旋转盘片为基础的设备。
    - **闪存**：半导体内存，比磁盘快，在个人移动设备中使用。

- **处理器**【CPU】：中央处理单元。central processor unit。从存储器中得到指令和数据。发出控制信号激活I/O设备。

  - **数据通路**：处理器中执行算数操作的部分。
  - **控制器**：指挥数据通路、存储器、输入和输出部件。

### 计算机通信

- **通信**：在计算机之间高速交换信息。
- **局域网**：在一定地理区域内使用的网络，通过交换器连接。
- **广域网**：以光纤为基础向通信公司租用，可支持万维网【World Wide Web】

## 处理器和存储器制造技术

- **晶体管**：由电信号控制的简单开关。
- **超大规模集成电路**【VLSI】：very large-scale integrated circuit，由数十万到数百万晶体管组成的电路。
- **瑕疵**：晶圆上的微小缺陷。
- **芯片**：chip，从晶圆中切割出来的单独的矩形区域。
- **成品率**：合格芯片占总芯片数的百分比。

### 公式

$$
每芯片价格 = 每晶圆价格 / (每晶圆的芯片数 * 成品率)
$$

$$
每晶圆芯片数 ≈ 晶圆面积 / 芯片面积
$$

$$
成品率 = 1 / (1 + 单位面积的瑕疵数 * 芯片面积 / 2)²
$$

## 性能

- **响应时间**：执行时间，计算机完成某任务的时间，包括硬盘访问、内存访问、I/O活动、操作系统开销和CPU执行时间。

  - CPU~~执行~~时间：执行某一任务在cpu上花费的时间。
    - 用户CPU时间：在程序本身所花费的cpu时间。
    - 系统CPU时间：在操作系统上花费的时间。

- **吞吐率**：带宽，单位时间内完成的任务数量。

- **时钟周期**：tick，通常为处理器时钟，一般为常数。处理器越好，时钟周期越短。

- **时钟频率**：时钟周期的倒数，单位时间内时钟周期的数量。

- **CPI**：每条指令的时钟周期数。

- **能耗**：一般为晶体管开关过程产生的能耗。功耗的极限限制了处理器发展，迫使进化成多核CPU。

- **并发挑战**：调度、负载均衡、通信以及同步开销。

- **MIPS**：million instructions per second，每秒百万条指令。

  

### 公式

$$
性能 = 1 / 响应时间
$$

$$
性能𝚡 / 性能𝚢 = 响应时间𝚢 / 响应时间𝚡
$$

$$
时钟频率 = 1 / 时钟周期
$$

$$
程序的CPU执行时间 = 程序的CPU时钟周期数 * 时钟周期时间
$$

$$
程序的CPU执行时间 = 程序的CPU时钟周期数 / 时钟频率
$$

$$
CPU时钟周期数 = 程序的指令数 * 每条指令的平均时钟周期数
$$

$$
CPU时间 = 指令数 * CPI * 时钟周期时间
$$

$$
CPU时间 = 指令数 * CPI / 时钟频率
$$

$$
能耗 ∝ 1/2 * 负载电容 * 电压²
$$

$$
能耗 ∝ 1/2 * 负载电容 * 电压² * 开关频率
$$

$$
改进后的执行时间 = 受改进影响的执行时间 / 改进量 + 不受改进的执行时间
$$

## ascii码对照表

## unicode对照表

# 指令

- **指令集**：一个给定的计算机体系结构所包含的指令集合。

## 硬件设计三条基本原则

- **简单源于规整**：例如加操作只能有3个操作数。
- **越小越快**：例如寄存器只有32个。寄存器一定比存储器快，功耗小。
- **优秀的设计需要适宜的折中方案**：指令设计的两种格式。

## MIPS 指令集

> 32位

### 操作数

|     名字      |                             示例                             |                             注释                             |
| :-----------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|  32个寄存器   | $s₀-$s₇<br>$t₀-$t₉<br>$zero<br>$a₀-a₃<br>$v₀-$v₁<br>$gp<br>$fp<br>$sp<br>$ra<br>$at |                      用于数据快速存取。                      |
| 2³⁰个存储器字 |              Memory[0]、Memory[4]...Memory[2³²]              | 只能通过数据传输指令访问，连续的字地址差4。<br>保存数据结构、数组和溢出的寄存器。 |

- **字**：计算机的基本访问单位，通常是32位一组，和寄存器大小相同。

- **位**：bit，是信息的基本组成单位。

- **字节**：8位为1字节。

- **寄存器**：reg。存放在寄存器后，才能执行算数操作。一般32个。

  |   名称    | 寄存器号 | 用途                       |
  | :-------: | :------: | -------------------------- |
  |   $zero   |    0     | 常数0                      |
  | $v₀ ~ $v₁ |  2 ~ 3   | 计算结果和表达式求值       |
  | $a₀ ~ $a₃ |  4 ~ 7   | 参数                       |
  | $t₀ ~ $t₇ |  8 ~ 15  | 临时变量                   |
  | $s₀ ~ $s₇ | 16 ~ 23  | 保存的寄存器               |
  | $t₈ ~ $t₉ | 24 ~ 25  | 更多临时变量               |
  |    $gp    |    28    | 全局指针，指向静态数据区。 |
  |    $sp    |    29    | 栈指针                     |
  |    $fp    |    30    | prpcedure frame，帧指针    |
  |    $ra    |    31    | 返回地址寄存器             |

  - 1：$at，被汇编器保留。
  - 26 ~ 27：$k₀ ~ $k₁，被操作系统保留。

- **数据传输指令**：在存储器和寄存器之间移动数据的命令。

- **地址**：用于在存储器空间中指明某特定数据元素位置的值。

- **对齐限制**：字的起始位置必须是4的倍数。

#### 常数或立即操作数

> 常数操作数出现频率高，从存储器中取常数比较慢，增加立即数是**加速大概率事件**。

#### 有符号数和无符号数

- **最低有效位**：字中最右边的一位。
- **最高有效位**：字中最左边的一位。
- **二进制补码**：前导为0表示正数，前导为1表示负数。
- **符号扩展**：取回有符号数时，会用符号位填充寄存器所有剩余位。
- **反码**：也表示按位求反。
- **偏移量表示法**：浮点数的一中表示发，通过将数加一个偏移使其具有非负的表示形式。

### 汇编语言

- **指令格式**：二进制数字字段组成的指令表示形式。
- **机器语言**：在计算机系统中用于交流的二进制表示形式。

#### 指令格式

- **R型**：用于寄存器。

  | 字段  | 位数 | 注释                         |
  | :---: | :--: | :--------------------------- |
  |  op   |  6   | 操作码                       |
  |  rs   |  5   | 第一个源操作数寄存器         |
  |  rt   |  5   | 第二个源操作数寄存器         |
  |  rd   |  5   | 用于存放操作结果的目的寄存器 |
  | shamt |  5   | 偏移量                       |
  | funct |  6   | 功能码，指明变式             |

- **I型**：用于立即数。

  |        字段         | 位数 | 注释                 |
  | :-----------------: | :--: | :------------------- |
  |         op          |  6   | 操作码               |
  |         rs          |  5   | 第一个源操作数寄存器 |
  |         rt          |  5   | 第二个源操作数寄存器 |
  | constant or address |  16  | 常数或地址           |
  
  - **PC**：正在被执行指令地址的寄存器。
  - **PC相对寻址**：一种寻址方式，将pc和指令中的常数作为寻址结果，条件分支的地址就是PC相对寻址。所以16位即可。

- **J型**：用于跳转指令。

  |  字段   | 位数 | 注释     |
  | :-----: | :--: | :------- |
  |   op    |  6   | 操作码   |
  | address |  26  | 跳转地址 |

  - **地址**：字地址，跳转范围可扩大4倍。

#### 指令

- **算数**

  |    指令    |      示例       |      含义       |       注释       |
  | :--------: | :-------------: | :-------------: | :--------------: |
  |    加法    | add $s₁,$s₂,$s₃ | $s₁ = $s₂ + $s₃ | 三个寄存器操作数 |
  |    减法    | sub $s₁,$s₂,$s₃ | $s₁ = $s₂ - $s₃ | 三个寄存器操作数 |
  | 立即数加法 | addi $s₁,$s₂,20 | $s₁ = $s₂ + 20  |  用于加常数数据  |

  |                指令 | 格式 | op   | rs   | rt   | rd   | shamt | funct | address |
  | ------------------: | :--: | :--- | :--- | ---- | ---- | ----- | ----- | ------- |
  |                 add |  R   | 0    | reg  | reg  | reg  | 0     | 32    | -       |
  |       sub[subtract] |  R   | 0    | reg  | reg  | reg  | 0     | 34    | -       |
  | addi[add immediate] |  I   | 8    | reg  | reg  | -    | -     | -     | 常数    |

- **数据传输**

  > - 取字：lord word，20 是偏移量。$s₂属于基址寄存器。

  |      指令      |      示例       |                含义                 |             注释             |
  | :------------: | :-------------: | :---------------------------------: | :--------------------------: |
  |      取字      | lw $s₁,20($s₂)  |       $s₁ = Memory[$s₂ + 20]        |  将一个字从内存取到寄存器中  |
  |      存字      | sw $s₁,20($s₂)  |       Memory[$s₂ + 20] = $s₁        |  将一个字从寄存器存到内存中  |
  |     取半字     | lh $s₁,20($s₂)  |       $s₁ = Memory[$s₂ + 20]        |  将半个字从内存取到寄存器中  |
  |  取无符号半字  | lhu $s₁,20($s₂) |       $s₁ = Memory[$s₂ + 20]        |  将半个字从内存取到寄存器中  |
  |     存半字     | sh $s₁,20($s₂)  |       Memory[$s₂ + 20] = $s₁        |  将半个字从寄存器存到内存中  |
  |     取字节     | lb $s₁,20($s₂)  |       $s₁ = Memory[$s₂ + 20]        | 将一个字节从内存取到寄存器中 |
  |  取无符号字节  | lbu $s₁,20($s₂) |       $s₁ = Memory[$s₂ + 20]        | 将一个字节从内存取到寄存器中 |
  |     存字节     | sb $s₁,20($s₂)  |       Memory[$s₂ + 20] = $s₁        | 将一个字节从寄存器存到内存中 |
  |    取链接字    | ll $s₁,20($s₂)  |       $s₁ = Memory[$s₂ + 20]        |  取字作为原子交换的前半部分  |
  |    存条件字    | sc $s₁,20($s₂)  | $s₁ = Memory[$s₂ + 20];$s₁ = 0 or 1 |  取字作为原子交换的后半部分  |
  | 取立即数的高位 |   lui $s₁,20    |           $s₁ = 20 * 2¹⁶            |     取立即数并放到高16位     |

  |           指令 | 格式 | op   | rs   | rt   | rd   | shamt | funct | address |
  | -------------: | :--: | :--- | :--- | ---- | ---- | ----- | ----- | ------- |
  |  lw[lord word] |  I   | 35   | reg  | reg  | -    | -     | -     | address |
  | sw[store word] |  I   | 43   | reg  | reg  | -    | -     | -     | address |

  - **加载32位立即数**

    ```assembly
    # 将立即数存放在寄存器的高16位，低16位补0
    lui $s₀,高16位
    # 插入低16位
    ori $s₀,$s₀,第16位
    ```

- **逻辑**

  |   指令   |      示例       |         含义         |          注释          |
  | :------: | :-------------: | :------------------: | :--------------------: |
  |    与    | and $s₁,$s₂,$s₃ |   $s₁ = $s₂ & $s₃    |  三个寄存器操作按位与  |
  |    或    | or $s₁,$s₂,$s₃  |   $s₁ = $s₂ \| $s₃   |  三个寄存器操作按位或  |
  |   或非   | nor $s₁,$s₂,$s₃ | $s₁ = ~ ($s₂ \| $s₃) | 三个寄存器操作按位或非 |
  | 立即数与 | andi $s₁,$s₂,20 |    $s₁ = $s₂ & 20    |      和常数按位与      |
  | 立即数或 | ori $s₁,$s₂,20  |    $s₁ = $s₂ \|20    |      和常数按位或      |
  | 逻辑左移 | sll $s₁,$s₂,10  |   $s₁ = $s₂ << 20    |   根据常数左移相应位   |
  | 逻辑右移 | srl $s₁,$s₂,10  |   $s₁ = $s₂ >> 20    |   根据常数右移相应位   |

  | 指令 | 格式 | op   | rs   | rt   | rd   | shamt | funct | address |
  | ---: | :--: | :--- | :--- | ---- | ---- | ----- | ----- | ------- |
  | 位移 |  R   | 0    | -    | reg  | reg  | 常数  | -     | -       |

- **条件分支**

  |                指令                |       示例       |                    含义                     |             注释             |
  | :--------------------------------: | :--------------: | :-----------------------------------------: | :--------------------------: |
  |             相等时跳转             |  beq $s₁,$s₂,25  |     if ($s₁ == $s₂) go to PC + 4 + 100      |  相等检测；和PC相关的跳转。  |
  |            不相等时跳转            |  bne $s₁,$s₂,25  |     if ($s₁ != $s₂) go to PC + 4 + 100      | 不相等检测；和PC相关的跳转。 |
  |             小于时置位             | slt $s₁,$s₂,$s₃  | if ($s₂ < $s₃) $s₁ = 1;<br />else  $s₁ = 0; |         比较是否小于         |
  |       无符号数比较小于时置位       | sltu $s₁,$s₂,$s₃ | if ($s₂ < $s₃) $s₁ = 1;<br />else  $s₁ = 0; |     比较是否小于无符号数     |
  |    无符号数比较小于立即数时置位    | slti $s₁,$s₂,20  | if ($s₂ < 20) $s₁ = 1;<br />else  $s₁ = 0;  |       比较是否小于常数       |
  | 无符号数比较小于无符号立即数时置位 | sltiu $s₁,$s₂,20 | if ($s₂ < 20) $s₁ = 1;<br />else  $s₁ = 0;  |    比较是否小于无符号常数    |

  - **不提供小于则分支**：过于复杂，会延长时钟周期时间。
  - 将有符号数作为无符号数来处理，常用语检查数组下标是否越界。

- **无条件跳转**

  |         指令         |   示例   |           含义            |              注释              |
  | :------------------: | :------: | :-----------------------: | :----------------------------: |
  |         跳转         |  j 2500  |        go to 10000        |         跳转到目标地址         |
  | 跳转至寄存器所指位置 |  jr $ra  |         go to $ra         | 用于 switch 语句，以及过程调用 |
  |      跳转并链接      | jal 2500 | $ra = PC + 4; go to 10000 |          用于过程调用          |

#### 寻址模式总结

> 根据对操作数和地址的使用不同加以区分的多种寻址方式中的一种。

- **立即数寻址**：操作数是唯一指令自身中的常数。
- **寄存器寻址**：操作数是寄存器。
- **基址【偏移】寻址**：操作数在内存中，地址是指令中基址寄存器和常数的和。
- **PC相对寻址**：地址是PC和指令中常数的和。
- **伪直接寻址**：地址由指令中26位字段和PC高位相连而成。

## 程序

### 逻辑操作

- **位移**：可解决乘法运算。
- **按位与**：两个操作位都为1，结果为1。
- **按位或**：两个操作位有1个为1，结果为1。
- **按位取反**：对操作数每位1变为0，0变为1。
- **或非**：两个操作位均为0，结果为1。
- **异或**：两个操作位值不同，结果为1。

### 决策指令

#### 循环

> 一般使用指令 j

- **基本块**：没有分支，并且没有分支目标/分支标签的指令序列。

#### case / switch 语句

> 一般使用指令 jr

- **转移地址表**：转移表，指包含不同指令序列地址的表。

### 过程【函数】

- **过程**：根据提供的参数执行一定任务的存储的子程序。

- **跳转和链接指令**：跳转到某个地址的同时将下一条指令的地址保存到寄存器$ra中的指令。

- **返回地址**：指向调用点的链接，是过程可以返回到合适的地址，存储在寄存器$ra中。

- **调用者**：调用一个过程并为过程提供必要参数值的程序。

- **被调用者**：根据调用者提供的参数执行一系列存储的指令，然后将控制权返回调用者的过程。

- **程序计数器**【PC】：包含在程序中正在被执行指令地址的寄存器。

- **过程帧**：也称作活动记录，栈中包含过程所保存的寄存器一级局部变量的片段。

  > <img src="./imgs/过程帧.png" alt="过程帧" style="zoom:50%;" />

- **帧指针**：指向给定过程中保存的寄存器和局部变量的值。指向过程帧的第一个字，**过程中栈指针可能会变化，而帧指针不会变化**。

- **尾递归**：可以使用尾迭代高效实现。

#### 过程运行步骤

1. 将参数放在过程可以访问的位置。
2. 将控制转交给过程。
3. 获得过程所需的存储资源。
4. 执行需要的任务。
5. 将结果的值放在调用程序可以访问的位置。
6. 将控制返回初始点，因为一个过程可能由一个程序的多个点调用。

#### 寄存器栈

- **过程调用保留**。

  | 保留                | 不保留                |
  | ------------------- | --------------------- |
  | 保存寄存器：$s₀-$s₇ | 临时寄存器：$t₀-$t₉   |
  | 栈指针寄存器：$sp   | 参数寄存器：$a₀-a₃    |
  | 返回地址寄存器：$ra | 返回值寄存器：$v₀-$v₁ |
  | 栈指针以上的栈      | 栈指针以下的栈        |

- **参数过多**：前4个放在放在 $a₀ ~ $a₃，其他的放在帧指针上方。

### 内存分配

<img src="./imgs/程序内存分配.png" alt="程序内存分配" style="zoom:50%;" />



### 字符串

- **字节存取**
  - 从栈中读取一个字节：`lb $t₀, 0($sp) `
  - 把寄存器最右边8位取出来写到内存中：`sb $t₀, 0($gp)`
- **字符表示方法**
  - 保留字符串的第一个位置用于给出字符串的长度。
  - 附加一个带有字符串长度的变量。
  - 字符串最后的位置用一个字符来标识结尾。

### 翻译并执行

## 并行与同步

- **数据竞争**：来自不同线程的两个访存请求访问同一个地址，连续出现，并且其中一个是写操作，存储访问形成数据竞争。

- **硬件原语**：提供对存储单元进行原子读和原子写的能力，多处理器中实现同步需要，存储器在进行原子度或原子写操作时任何其他操作都不得插入。

- **原子操作实现**：指令对，其他处理器不能改变两个指令执行之间的数据值。

  > 两条指令之间的任何时候有处理器插入，并且修改了该单元的值，指令sc都会将$t₀置为0，引起指令序列重新执行。

  - 取连接数：ll，laod linked。
  - 条件存数：sc，store conditional。


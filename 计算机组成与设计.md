# 指导思想

## 八个伟大思想

- **面向摩尔定律的设计**：预测项目完成时的工艺水平。
- **使用抽象简化设计**：层次间不关注细节。
- **加速大概率事件**：对大概率会发生的事件进行提速。
- **通过并行提高性能**
- **通过流水线提高性能**
- **通过预测提高性能**：通过预测的方式提前开始某些操作。
- **存储器层次**：快且昂贵的作为存储器顶层、慢且便宜的作为存储器底层。
- **通过冗余提高可靠性**：冗余部件或数据。

## 硬件设计三条基本原则

- **简单源于规整**：例如加操作只能有3个操作数。
- **越小越快**：例如寄存器只有32个。寄存器一定比存储器快，功耗小。
- **优秀的设计需要适宜的折中方案**：指令设计的两种格式。

# 逻辑设计

## 信号

- **有效信号**：信号为逻辑1或真。
- **无效信号**：信号为逻辑0或假。

## 组合逻辑

> 不包含存储元件，因此当输入相同的数据时，将得到相同的输出。

### 描述方式

#### 真值表

> 描述组合逻辑，每一项都指定了特定输入对应的所有输入的数值。

|      | 输入 |      |      | 输出 |      |
| ---- | ---- | ---- | ---- | ---- | ---- |
| A    | B    | C    | D    | E    | F    |
| 0    | 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 1    | 0    | 0    |
| 0    | 1    | 0    | 1    | 0    | 0    |
| 0    | 1    | 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 1    | 0    | 0    |
| 1    | 0    | 1    | 1    | 1    | 0    |
| 1    | 1    | 0    | 1    | 1    | 0    |
| 1    | 1    | 1    | 1    | 0    | 1    |

#### 布尔代数

- **表示方式**

  | 操作 | 标记          |
  | ---- | ------------- |
  | 或   | +             |
  | 与   | ·             |
  | 非   | A<sup>-</sup> |

- **定律**

  | 定律        | 解释                                                         |
  | ----------- | ------------------------------------------------------------ |
  | 同一定律    | A + 0 = A; A · 1 = A                                         |
  | 0 和 1 定律 | A + 1 = 1; A · 0 = 0                                         |
  | 互补定律    | A + A<sup>-</sup> = 1; A · A<sup>-</sup> = 0                 |
  | 交换律      | A + B = B + A; A · B = B · A                                 |
  | 结合律      | A + B + C = A + (B + C); A · B · C = A · (B · C)             |
  | 分配律      | A · (B + C) = (A · B) + (A · C); A + (B · C) = (A + B) · (A + C) |

#### 硬件描述语言

> 一种描述硬件的编程语言，硬件描述语言用来模拟硬件设计，同时也作为综合工具的输入来生成具体的硬件。

- **两种描述语言**：Verilog、VHDl。

- **两种描述方式**
  - **行为级描述**：描述一个数字系统在功能方面是怎么工作的。
  - **结构级描述**：描述一个数字系统是如何通过基本元件的层次化连接进行组织的。
- **硬件综合工具**：一种计算机辅助设计软件，该软件可以通过数字系统的行为级描述来生成门级的设计结果。

### 门

> 实现基本逻辑功能的硬件设备，比如与门、或门、非门。

| 门     | 标记                                                         |
| ------ | ------------------------------------------------------------ |
| 与门   | <img src="./imgs/与门.png" alt="image-20220525063336053" style="zoom:50%;" /> |
| 或门   | <img src="./imgs/或门.png" alt="image-20220525063411456" style="zoom:50%;" /> |
| 非门   | <img src="./imgs/非门.png" alt="image-20220525063538963" style="zoom:50%;" /> |
| 与非门 | <img src="./imgs/与非门.png" alt="image-20220525063713068" style="zoom:50%;" /> |

### 多路选择器

> - **选择信号**：也称为控制信号，用来选择某一个输入信号，来作为多路选择器的输出信号。
> - **译码器**：拥有n位输入和2<sup>n</sup>个输出的逻辑块。<img src="./imgs/译码器.png" alt="译码器" style="zoom:50%;" />；对每一个输入组合，只有一个输出信号为真。



- **两信号选择器**：<img src="./imgs/两信号选择器.png" alt="两信号选择器" style="zoom:50%;" />；**记为**：<img src="./imgs/多路选择器记号.png" alt="多路选择器记号" style="zoom:50%;" />

- **八输入的信号选择器**：<img src="./imgs/8个输入的信号选择器.png" alt="8个输入的信号选择器" style="zoom:50%;" />

### PLA

> **programmable logic array**，**可编程逻辑阵列**
>
> - 是一种结构化逻辑单元。由一组输入信号及反向信号和一个两级逻辑构成。
> - 第一级逻辑用来生成输入信号和反向信号的**乘积项**。**也叫最小项**。
> - 第二级逻辑用来生成这些乘积项的和。

- **两级逻辑**
  - **乘积和**：一种逻辑表达形式，对所有乘积【与操作】进行逻辑求和【或操作】。

  - **和积项**：一种逻辑表达形式，对所有求和【或操作】进行逻辑乘积【与操作】。


#### 真值表与其对应的实现

- **真值表**

  |      | 输入 |      |      | 输出 |      |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | A    | B    | C    | D    | E    | F    |
  | 0    | 0    | 0    | 0    | 0    | 0    |
  | 0    | 0    | 1    | 1    | 0    | 0    |
  | 0    | 1    | 0    | 1    | 0    | 0    |
  | 0    | 1    | 1    | 1    | 1    | 0    |
  | 1    | 0    | 0    | 1    | 0    | 0    |
  | 1    | 0    | 1    | 1    | 1    | 0    |
  | 1    | 1    | 0    | 1    | 1    | 0    |
  | 1    | 1    | 1    | 1    | 0    | 1    |

- **pla实现**

  <img src="./imgs/pla.png" alt="image-20220526011518643" style="zoom:50%;" />

### ROM

> ROM是是完全译码，PLA是部分译码。

- **只读存储器**【ROM】：一类存储器，数据在制造时就固定下来，之后其数据只能被读。ROM作为逻辑化结构，可以将逻辑函数组中的项作为输入地址，将输出作为存储器中的一个字，以此来实现逻辑函数组。
- **可编程POM**【PROM】：一类只读存储器，但是当设计者知道其中的数据时，可以对其进行编程。

### 无关项

> 在真值表中记为X，**可以简化逻辑函数的实现**。
>
> - **无关项的输入**：对一些输入组合产生的输出不太关心。
> - **无关项的输出**：当输出只取决于一部分输入时。

#### 简化后的真值表

> 1. 不管B的值为多少，只要A或C为真，则输出D为真。
> 2. 不管C的值为多少，只要A或B为真，则输出E为真。
> 3. 虽然D和E都为真时，我们不关心F的值，但是如果三个输入中一个为真，则输出F为真。

- **原真值表**

  |      | 输入 |      |      | 输出 |      |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | A    | B    | C    | D    | E    | F    |
  | 0    | 0    | 0    | 0    | 0    | 0    |
  | 0    | 0    | 1    | 1    | 0    | 1    |
  | 0    | 1    | 0    | 0    | 1    | 1    |
  | 0    | 1    | 1    | 1    | 1    | 0    |
  | 1    | 0    | 0    | 1    | 1    | 1    |
  | 1    | 0    | 1    | 1    | 1    | 0    |
  | 1    | 1    | 0    | 1    | 1    | 0    |
  | 1    | 1    | 1    | 1    | 1    | 0    |

- **加上无关项**

  |      | 输入 |      |      | 输出 |      |
  | ---- | ---- | ---- | ---- | ---- | ---- |
  | A    | B    | C    | D    | E    | F    |
  | 0    | 0    | 0    | 0    | 0    | 0    |
  | 0    | 0    | 1    | 1    | 0    | 1    |
  | 0    | 1    | 0    | 0    | 1    | 1    |
  | x    | 1    | 1    | 1    | 1    | x    |
  | 1    | x    | x    | 1    | 1    | x    |

- **最终逻辑实现**

  > 只需要4个最小项。

### 逻辑单元阵列

> 很多操作需要一次处理整个字，所以我们会构建一个逻辑单元的阵列，通过将一个操作作用在整个输入的集合中来实现。
>
> 一般由一个选择信号串联整个阵列。

- **具体实现**：<img src="./imgs/总线.png" alt="image-20220526220818512" style="zoom:50%;" />;**记为**：<img src="./imgs/简化逻辑阵列.png" alt="简化逻辑阵列" style="zoom:50%;" />
  - **总线**：在逻辑设计中，由多个数据线构成的一条逻辑线，这些数据线被同时执行；被多个源使用的一组信号线也可以称为总线。


### ALU

> arithmetic logic unit，算术逻辑单元。

#### 一位ALU

- **真值表**

  |      | 输出 |          | 输出     |      |
  | ---- | ---- | -------- | -------- | ---- |
  | a    | b    | 进位输入 | 进位输出 | 和   |
  | 0    | 0    | 0        | 0        | 0    |
  | 0    | 0    | 1        | 0        | 1    |
  | 0    | 1    | 0        | 0        | 1    |
  | 0    | 1    | 1        | 1        | 0    |
  | 1    | 0    | 0        | 0        | 1    |
  | 1    | 0    | 1        | 1        | 0    |
  | 1    | 1    | 0        | 1        | 0    |
  | 1    | 1    | 1        | 1        | 1    |

- **加法进位器**：<img src="./imgs/加法进位器.png" alt="image-20220526225354303" style="zoom:50%;" />;记为：<img src="./imgs/加法进位器记号.png" alt="加法进位器记号" style="zoom:50%;" />

- **与和或逻辑单元实现**：<img src="./imgs/与和或选择器.png" alt="与和或选择器" style="zoom:50%;" />

- **ALU实现**：<img src="./imgs/一位ALU.png" alt="一位ALU" style="zoom:50%;" />

  > - **与**：操作信号和A、B反转器信号为0。
  > - **或**：操作信号1，A、B反转器信号为0。
  > - **或非**：操作信号0，A、B反转器信号为1。(a + b)<sup>-</sup> = a · b<sup>-</sup>
  > - **加**：操作信号2，A、B反转器信号为0。
  > - **减**：操作信号2，A反转器信号为0，B反转器信号为1，进位为1。

#### 32位ALU

- **波形进位**：就是将32个alu串联起来。

  > <img src="./imgs/波形进位.png" alt="波形进位" style="zoom:50%;" />
  >
  > **实现的运算如下**：1位表示A反转信号，1位表示B反转信号【**可以将反转信号和进位信号用1跟控制线，因为减法除了按位取反，个位还得+1**】，2位表示操作选择信号
  >
  > | ALU控制线 | 功能       | 描述                                                         |
  > | --------- | ---------- | ------------------------------------------------------------ |
  > | 0000      | 与         |                                                              |
  > | 0001      | 或         |                                                              |
  > | 0010      | 加         |                                                              |
  > | 0110      | 减         |                                                              |
  > | 0110      | 等于则置零 | 减操作后看置零标志                                           |
  > | 0111      | 小于则置位 | 最低位输入减法操作后的最高位，作为置位标识输入第一个ALU。<br />其他ALU输入0，最终的结果就是置位结果。 |
  > | 1100      | 或非       |                                                              |
  >
  > **记为**：<img src="./imgs/ALU操作.png" alt="ALU操作" style="zoom:50%;" />

- **超前进位**

  > **理论依据**：c代表进位，a，b代表输入。
  >
  > - c<sub>i+1</sub> = (a<sub>i</sub> · b<sub>i</sub>) + (b<sub>i</sub> · c<sub>i</sub>) + (a<sub>i</sub> · c<sub>i</sub>) =  (a<sub>i</sub> · b<sub>i</sub>) +  (a<sub>i</sub> + b<sub>i</sub>) · c<sub>i</sub>
  > - 设：g<sub>i</sub> = a<sub>i</sub> · b<sub>i</sub>【进位产生函数】; p<sub>i</sub> = a<sub>i</sub> + b<sub>i</sub>【进位传输函数】。
  >   - c<sub>1</sub> = g<sub>0</sub> + (p<sub>0</sub> · c<sub>0</sub>)
  >   - c<sub>2</sub> = g<sub>1</sub> + (p<sub>1</sub> · g<sub>0</sub>) +  (p<sub>1</sub> · p<sub>0</sub> · c<sub>0</sub>)
  >   - c<sub>3</sub> = g<sub>2</sub> + (p<sub>2</sub> · g<sub>1</sub>) +  (p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub>) +  (p<sub>2</sub> · p<sub>1</sub> · p<sub>0</sub> · c<sub>0</sub>)
  >   - c<sub>4</sub> = g<sub>3</sub> + (p<sub>3</sub> · g<sub>2</sub>) +  (p<sub>3</sub> · p<sub>2</sub> · g<sub>1</sub>) +  (p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub>) +  (p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · p<sub>0</sub> · c<sub>0</sub>)

  - **第一级抽象**：<img src="./imgs/第一抽象级.png" alt="第一抽象级" style="zoom:50%;" />

  - **第二抽象级**：<img src="./imgs/第二抽象级.png" alt="第二抽象级" style="zoom:50%;" />

    > 以4个为一组时。考虑成水管流通。<img src="./imgs/第二抽象级-因子.png" alt="第二抽象级-因子" style="zoom:20%;" />
    >
    > - **进位传输因子**：P<sub>0</sub> = p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · p<sub>0</sub>
    > - **进位产生因子**：G<sub>0</sub> = g<sub>3</sub> + (p<sub>3</sub> · g<sub>2</sub>) +  (p<sub>3</sub> · p<sub>2</sub> · g<sub>1</sub>) +  (p<sub>3</sub> · p<sub>2</sub> · p<sub>1</sub> · g<sub>0</sub>)
    > - C<sub>1</sub> = G<sub>0</sub> + (P<sub>0</sub> · C<sub>0</sub>)

## 时序逻辑

> 包含存储元件，输出取决于输入和当前存储元件的内容。

### 时钟

> 在时序电路中非常重要，决定了处于某一状态的存储元件合适被更新。是一个具有固定周期时间的不停运转的信号。【脉冲】

- **时钟周期**：分为高电平时钟和低电平时钟。

- **边沿触发时钟**：一种时钟机制，在这种机制下所有的状态改变都发生在时钟边沿。

  > 采用原因：易于描述，应用简单。

- **时钟同步方法**：一种根据时钟来决定数据何时有效和稳定的办法。

- **状态单元**：存储元件。

- **同步系统**：一个使用时钟的存储系统，且数据信号只有在当前时钟下是处于稳定状态才可被读取。

#### 时钟控制原理

- **时钟偏斜**：对不同的状态单元，时钟电路到达的时间有细微差别。两个状态单元看到时钟沿的绝对时间差别。

  > 时钟偏斜可能引发竞争现象，引起错误操作，例如后面的触发器的时钟有效信号到达之前，由于第一个触发器时钟信号已触发，经过组合电路后，后面的触发器的输入已经发生了变化。

- **时钟周期公式**：时钟周期 = t<sub>prop</sub> + t<sub>combinational</sub> + t<sub>setup</sub> + t<sub>skew</sub>

  > <img src="./imgs/时钟周期.png" alt="时钟周期" style="zoom:50%;" />
  >
  > -  t<sub>prop</sub>：信号通过触发器传播的时间。即触发器的输入到输出。
  > - t<sub>combinational</sub>：对于任何组合逻辑的最长延时。
  > - t<sub>setup</sub>：在上升沿到来前，触发器输入必须有效的时间。
  > - t<sub>skew</sub>：时钟偏斜时间。最好不要超过最小的触发器传播时间。

#### 电平敏感时控原理

- **双相时钟控制**：交替锁存器。

  <img src="./imgs/双相时钟周期.png" alt="双相时钟周期" style="zoom:50%;" />

  <img src="./imgs/交替锁存器的时钟控制方法.png" alt="交替锁存器的时钟控制方法" style="zoom:50%;" />

#### 异步输入和同步器

- **亚稳态**：如果采样时信号不满足建立时间和保持时间的要求，采样所得的数据可能是结余高电平和低电平之间的一个错误值。
- **异步输入**：在实际系统中，CPU有自己的时钟信号，I/O设备也有自己的时钟信号。

- **同步器**：<img src="./imgs/同步器.png" alt="同步器" style="zoom:50%;" />

  > 将异步输入信号转化为同步信号并用于改变系统的状态量。输入为异步信号和独立的时钟信号，输出为与此输入时钟同步的信号。

  - **两个D触发器的原因**：一个触发器的输出可能会有亚稳态，亚稳态作为第二个触发器的输入，等退出亚稳态后再接收该同步器的输入信号。

- **同步失败**：触发器进入亚稳态，并且有些逻辑模块读到触发器输出为0，另外一些模块读到触发器输出为1。

### 存储元件

#### 锁存器

> 它的输出与内部存储的状态一致，并且当时钟有效时，只要输入发生变化，存储状态就会随之发生变化。

- **S-R【set-reset】锁存器**：<img src="./imgs/SR锁存器.png" alt="SR锁存器" style="zoom:50%;" />

  > - S：置位信号：S为1时，Q为0。
  > - R：复位信号：R为1时，Q为1。
  > - S和R不可同时有信号。
  > - Q：存储的数据。
  > - Q‘：存储数据的反向数据。
  >
  > 该装置在无信号输入时可保证存储状态稳定。

- **D锁存器**：<img src="./imgs/D锁存器.png" alt="D锁存器" style="zoom:50%;" />；记作：<img src="./imgs/D锁存器记号.png" alt="D锁存器记号" style="zoom:50%;" />

  > - D为要存储的数据。
  > - C为时钟信号
  >   - 当有时钟信号时，Q的存储内容和D相同。
  >   - 当没有时钟信号时，无论D信号为任何内容，Q的存储内容不会发生变化。

#### 触发器

> 基本构造单元
>
> 它的输出与内部存储的状态一致，并且内部状态只在时钟的边沿发生变化。
>
> - **D触发器**：一个包含一个输入数据的触发器，这类触发器只在时钟信号的边沿，才将输入信号存储到内部元件中。

- **上升沿触发的D触发器**：<img src="./imgs/上升沿.png" alt="上升沿" style="zoom:50%;" />

  > - 当时钟信号有效时，主锁存器【第一个】打开，输入数据D。
  > - 当时钟信号拉低时，主锁存器关闭，D数据输出Q。

- **下降沿触发的D触发器**：<img src="./imgs/下降沿触发.png" alt="下降沿触发" style="zoom:50%;" />

  > - **建立时间**：在时钟发生跳变前，输入信号必须保持有效的最短时间。
  > - **保持时间**：在时钟跳变后，输入信号需要保持的最短的有效时间。
  >
  > <img src="./imgs/建立&保持时间.png" alt="image-20220527224301272" style="zoom:30%;" />

#### 寄存器堆

> 包含一组可读写的寄存器，读写通过指定寄存器号进行。
>
> 一条指令通常包含两个读，一个写。

- **寄存器堆**：<img src="./imgs/寄存器文件.png" alt="寄存器文件" style="zoom:50%;" />

  - **问**：如果在同一个时钟周期中，对寄存器同时进行读和写，将会发生什么？

    > 读到的数据是上一个时钟周期写入的数据。如果想要读出当前正在写入的数据，需要在寄存器内部或外部添加额外的逻辑。

- **寄存器堆读端口实现**：<img src="./imgs/寄存器读.png" alt="寄存器读" style="zoom:50%;" />

- **寄存器堆写端口实现**：<img src="./imgs/寄存器写.png" alt="寄存器写" style="zoom:50%;" />

  > 需要三个输入：寄存器号，要写入的数据和一个控制写入的时钟。
  >
  > - 寄存器号用译码器生成一个信号和时钟信号一起组成写信号。
  > - 寄存器数据直接作为触发器的数据写入。

#### 静态随机访问存储器【SRAM】



#### 动态随机访问存储器【DRAM】

### 有限状态机

<img src="./imgs/有限状态机.png" alt="有限状态机" style="zoom:50%;" />

- **有限状态机**：**用来描述时序系统**。一个包含一套输入、输出函数和下一状态函数的时序逻辑函数。
  - 其中下一状态函数根据当前状态和输入产生一个新的状态。
  - 输出函数根据当前状态和输入【有时不需要输入】确定输出的控制信号。
- **下一状态函数**：是一个组合函数，根据输入和当前状态确定有限状态机的下一状态。
- **一种实现方式**：<img src="./imgs/有限状态机实现.png" alt="有限状态机实现" style="zoom:50%;" />

## 现场可编程设备

- **现场可编程设备【FPD】**：一种包含组合逻辑，可能也包含存储设备的集成电路，最终用户可以对其进行配置。
- **可编程逻辑设备【PLD】**：包含最终用户可配置功能的组合逻辑的集成电路。
- **现场可编程门阵列【SPLD】**：一种可配置的包含组合逻辑模块和触发器的集成电路。
- **简单可编程逻辑设备【SPLD】**：一种可编程逻辑器件，通常包含一块PAL或PLA。
- **可编程阵列逻辑【PAL**】：有一个可编程的与门阵列后跟一个可编程的或阵列组成的可编程逻辑电路。
- **反熔丝**：集成电路中的一种结构，当对其进行编程时，将导致线间的永久性连接。
- **查找表【LUT】**：现场可编程器件中的单元的名称，包含少量的逻辑和RAM。

# 计算机概要与技术

## 程序概念

- **系统软件**：提供常用服务的软件。包括操作系统、编译程序、加载程序和汇编程序等。
- **操作系统**：用户程序和硬件之间的接口。
  - 处理输入输出。
  - 分配外存和内存。
  - 提供应用间共享的计算机资源。
- **高级程序语言**：可以由编译器转换为汇编语言。
  - 语言表达更自然。
  - 提高生产率。
  - 提高移植性。
- **编译程序【编译器】**：将高级语言翻译成汇编语言。
- **汇编程序**：将指令由助记符翻译成二进制形式。
  - *汇编语言*：用助记符形式表示的语言。
  - *机器语言*：以二进制形式表示的机器指令。

## 硬件

> - 集成电路：也叫芯片，将几十至几百万个晶体管连接起来的设备。
> - 指令集体系【体系结构】：是低层次软件和硬件之间的抽象接口，包含了指令、寄存器、存储访问、和I/O等。
>   - 应用二进制接口：用户部分指令和应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。
>   - 实现：遵循体系结构抽象的硬件。

- **输入设备**：将数据写入存储器。

  > 键盘、鼠标。

- **输出设备**：从内存中读出数据。

  - *显示器*
    - **液晶显示**【LCD】：一种显示技术，**控制光的传输，非光源**。用液体聚合物薄层的带电或者不带电来传输或组织光线的传输。
    - **动态矩阵显示**：液晶显示技术，使用晶体管控制单个像素上光纤的传输。
    - **彩色动态矩阵**：每个像素有红绿蓝3类晶体管开关。
      - **位图**：图像由像素矩阵组成，可表示成二进制位的矩阵。
      - **分辨率**：矩阵的大小。如 1024 * 768。
      - **帧缓冲区**：保存位图，以刷新频率输出到显示设备。
    - **像素**：图像元素的最小单元。每个像素24位。
  - *触摸屏*：平板采取电容感应实现。

- **存储器**

  - **主存储器**：易失性存储器，仅在加电时保存数据。
    - **缓存**：处理器内使用，小而快的存储器，作为内存的缓冲。
      - **SRAM**：static random access memory，**静态随机访问存储器**，集成电路式，比
    - **内存**：程序运行时的存储空间，同时存储程序运行时所需数据。
      - **DRAM**：dynamic random access memory，**动态随机访问存储器**，集成电路式，可随机访问任何地址，时间一样。
  - **二级存储器**：非易失性存储器，在掉电时仍保持数据。
    - **磁盘**：硬盘，以旋转盘片为基础的设备。
    - **闪存**：半导体内存，比磁盘快，在个人移动设备中使用。

- **处理器**【CPU】：中央处理单元。central processor unit。从存储器中得到指令和数据。发出控制信号激活I/O设备。

  - **数据通路**：处理器中执行算数操作的部分。
  - **控制器**：指挥数据通路、存储器、输入和输出部件。

### 计算机通信

- **通信**：在计算机之间高速交换信息。
- **局域网**：在一定地理区域内使用的网络，通过交换器连接。
- **广域网**：以光纤为基础向通信公司租用，可支持万维网【World Wide Web】

## 处理器和存储器制造技术

- **晶体管**：由电信号控制的简单开关。
- **超大规模集成电路**【VLSI】：very large-scale integrated circuit，由数十万到数百万晶体管组成的电路。
- **瑕疵**：晶圆上的微小缺陷。
- **芯片**：chip，从晶圆中切割出来的单独的矩形区域。
- **成品率**：合格芯片占总芯片数的百分比。

### 公式

$$
每芯片价格 = 每晶圆价格 / (每晶圆的芯片数 * 成品率)
$$

$$
每晶圆芯片数 ≈ 晶圆面积 / 芯片面积
$$

$$
成品率 = 1 / (1 + 单位面积的瑕疵数 * 芯片面积 / 2)²
$$

## 性能

- **响应时间**：执行时间，计算机完成某任务的时间，包括硬盘访问、内存访问、I/O活动、操作系统开销和CPU执行时间。

  - CPU~~执行~~时间：执行某一任务在cpu上花费的时间。
    - 用户CPU时间：在程序本身所花费的cpu时间。
    - 系统CPU时间：在操作系统上花费的时间。

- **吞吐率**：带宽，单位时间内完成的任务数量。

- **时钟周期**：tick，通常为处理器时钟，一般为常数。处理器越好，时钟周期越短。

- **时钟频率**：时钟周期的倒数，单位时间内时钟周期的数量。

- **CPI**：每条指令的时钟周期数。

- **能耗**：一般为晶体管开关过程产生的能耗。功耗的极限限制了处理器发展，迫使进化成多核CPU。

- **并发挑战**：调度、负载均衡、通信以及同步开销。

- **MIPS**：million instructions per second，每秒百万条指令。

  

### 公式

$$
性能 = 1 / 响应时间
$$

$$
性能𝚡 / 性能𝚢 = 响应时间𝚢 / 响应时间𝚡
$$

$$
时钟频率 = 1 / 时钟周期
$$

$$
程序的CPU执行时间 = 程序的CPU时钟周期数 * 时钟周期时间
$$

$$
程序的CPU执行时间 = 程序的CPU时钟周期数 / 时钟频率
$$

$$
CPU时钟周期数 = 程序的指令数 * 每条指令的平均时钟周期数
$$

$$
CPU时间 = 指令数 * CPI * 时钟周期时间
$$

$$
CPU时间 = 指令数 * CPI / 时钟频率
$$

$$
能耗 ∝ 1/2 * 负载电容 * 电压²
$$

$$
能耗 ∝ 1/2 * 负载电容 * 电压² * 开关频率
$$

$$
改进后的执行时间 = 受改进影响的执行时间 / 改进量 + 不受改进的执行时间
$$

# 编译器

- **谬误**：更强大的指令意味着更高的性能。
- **谬误**：使用汇编语言编程来获得更高的性能。
- **谬误**：商用计算器二进制兼容的重要性意味着成功的指令集不需改变。
- **陷阱**：忘记在字节寻址机器中，连续的字地址相差不是1。**是4，字节编址**。
- **陷阱**：在自动变量的定义过程外，使用指针指向该变量。**过程栈的数据会被覆盖**。

## 名词解释

- **指令**

  - **指令集**：一个给定的计算机体系结构所包含的指令集合。
  - **指令格式**：二进制数字字段组成的指令表示形式。
  - **机器语言**：在计算机系统中用于交流的二进制表示形式。
  - **数据传输指令**：在存储器和寄存器之间移动数据的命令。

- **字**：计算机的基本访问单位，通常是32位一组。

  - **双字**：通常是64位一组。
  - **位**：bit，是信息的基本组成单位。
  - **字节**：8位为1字节。
  - **对齐限制**：字的起始位置必须是4的倍数。

- **寄存器**：reg。存放在寄存器后，才能执行算数操作。一般32个通用寄存器。

  - **通用寄存器**：可用于存储任何指令的地址或数据的寄存器。
  - **程序计数器**【PC】：包含在程序中正在被执行指令地址的寄存器。

- **地址**：用于在存储器空间中指明某特定数据元素位置的值。

  - **PC**：正在被执行指令地址的寄存器。
  - **PC相对寻址**：一种寻址方式，将pc和指令中的常数作为寻址结果，条件分支的地址就是PC相对寻址。所以16位即可。
  - **字地址**：地址指令用，跳转范围可扩大4倍。
  - **寻址模式**：根据对操作数和地址的使用不同有五种寻址模式。
    - **立即数寻址**：操作数是唯一指令自身中的常数。
    - **寄存器寻址**：操作数是寄存器。
    - **基址【偏移】寻址**：操作数在内存中，地址是指令中基址寄存器和常数的和。
    - **PC相对寻址**：地址是PC和指令中常数的和。
  - **转移地址表**：转移表，指包含不同指令序列地址的表。case / swich语句使用。

- **有符号数**

  - **最低有效位**：双字中最右边的位。
  - **最高有效位**：双字中最左边的位。
  - **二进制补码**：一个n位数与其n位相反数的无符号和为2<sup>n</sup> - 1。
  - **偏移表示法**：用00...00表示最小负数，用11...11表示最大正数。
  - **符号扩展**：取回有符号数时，会用符号位填充寄存器所有剩余位。
  - **反码**：也表示按位求反。

- **过程**：根据提供的参数执行一定任务的存储的子程序

  - **返回地址**：指向调用点的链接，是过程可以返回到合适的地址，存储在寄存器x1中。

  - **调用者**：调用一个过程并为过程提供必要参数值的程序。

  - **被调用者**：根据调用者提供的参数执行一系列存储的指令，然后将控制权返回调用者的过程。

  - **过程帧**：也称作活动记录，栈中包含过程所保存的寄存器一级局部变量的片段。<img src="./imgs/过程帧.png" alt="过程帧" style="zoom:30%;" />

    

  - **叶过程**：不调用其他过程的过程。

  - **帧指针**：指向过程帧的第一个字，**过程中栈指针可能会变化，而帧指针不会变化**。

  - **尾递归**：可以使用尾迭代高效实现。

- **逻辑操作**

  - **与**：两个操作位都为1，结果为1。
  - **或**：两个操作位有1个为1，结果为1。
  - **非**：对操作数每位1变为0，0变为1。
  - **异或**：两个操作位值不同，结果为1。

## 相关表格

### 寄存器存储

|   名称    | 寄存器号 | 用途                   |
| :-------: | :------: | ---------------------- |
|    x0     |    0     | 常数0                  |
|  x1(ra)   |    1     | 返回赋值【链接寄存器】 |
|  x2(sp)   |    2     | 栈指针                 |
|  x3(gp)   |    3     | 全局指针               |
|  x4(tp)   |    4     | 线程指针               |
|  x5 ~ x7  |  5 ~ 7   | 临时寄存器             |
|  x8 ~ x9  |  8 ~ 9   | 保存寄存器，x8帧指针   |
| x10 ~ x17 | 10 ~ 17  | 参数 / 结果            |
| x18 ~ x27 | 18 ~ 27  | 保存寄存器             |
| x28 ~ x31 | 28 ~ 31  | 临时寄存器             |

### RISC-V操作数

|           名字           |                     示例                      | 注释                                                         |
| :----------------------: | :-------------------------------------------: | :----------------------------------------------------------- |
|        32个寄存器        |                  $x0 ~ $x31                   | 用于数据快速存取。                                           |
|      32个浮点寄存器      |                  $f₀ ~ $f₃₁                   | 成对地使用MIPS浮点寄存器来保存双精度数                       |
| 2<sup>61</sup>个存储器字 | Memory[0]、Memory[8]...Memory[2<sup>64</sup>] | 只能通过数据传输指令访问，连续的字地址差8。<br>保存数据结构、数组和溢出的寄存器。 |
|     常数或立即操作数     |                                               | 常数操作数出现频率高，从存储器中取常数比较慢。<br />增加立即数是**加速大概率事件**。 |

### RISC-V六类指令

#### 算数

|     指令 | 示例          | 含义         | 注释                       |
| -------: | :------------ | :----------- | :------------------------- |
|     加法 | add x5,x6,x7  | x5 = x6 + x7 | 三个寄存器操作数，检测溢出 |
|     减法 | sub x5,x6,x7  | x5 = x6 - x7 | 三个寄存器操作数，检测溢出 |
| 加立即数 | addi x5,x6,20 | x5 = x6 + 40 | 加常数，检测溢出           |

#### 数据传输

|             指令 | 示例           | 含义                                   | 注释                         |
| ---------------: | :------------- | :------------------------------------- | :--------------------------- |
|           取双字 | ld x5,40(x6)   | x5 = Memory[x6 + 40]                   | 从存储器取双字到寄存器       |
|           存双字 | sd x5,40(x6)   | Memory[x6 + 40] = x5                   | 从寄存器存双字到存储器       |
|             取字 | lw x5,40(x6)   | x5 = Memory[x6 + 40]                   | 从存储器取字到寄存器         |
|   取字【无符号】 | lwu x5,40(x6)  | x5 = Memory[x6 + 40]                   | 从存储器取无符号字到寄存器   |
|             存字 | sw x5,40(x6)   | Memory[x6 + 40] = x5                   | 从寄存器存字到存储器         |
|           取半字 | lh x5,40(x6)   | x5 = Memory[x6 + 40]                   | 从存储器取半字到寄存器       |
|     取无符号半字 | lhu x5,40(x6)  | x5 = Memory[x6 + 40]                   | 从存储器取半字到寄存器       |
|           存半字 | sh x5,40(x6)   | Memory[x6 + 40] = x5                   | 从寄存器存半字到存储器       |
|           取字节 | lb x5,40(x6)   | x5 = Memory[x6 + 40]                   | 从存储器取字节到寄存器       |
| 取字节【无符号】 | lbu x5,40(x6)  | x5 = Memory[x6 + 40]                   | 从存储器取无符号字节到寄存器 |
|           存字节 | sb x5,40(x6)   | Memory[x6 + 40] = x5                   | 从寄存器存字节到存储器       |
|         取保留字 | lr.d x5,40(x6) | x5 = Memory[x6 + 40]                   | 取：原子交换的前半部分       |
|         存条件字 | sc.d x5,40(x6) | x5 = Memory[x6 + 40]<br />;x5 = 0 or 1 | 存：原子交换的后半部分       |
|   取立即数的高位 | lui x5,0x12345 | x5 = 0x12345000                        | 取左移12位后的20位立即数     |

#### 逻辑

|       指令 | 示例          | 含义          | 注释                     |
| ---------: | :------------ | :------------ | :----------------------- |
|         与 | and x5,x6,x7  | x5 = x6 & x7  | 三个寄存器操作：按位与   |
|         或 | or x5,x6,x7   | x5 = x6 \| x7 | 三个寄存器操作：按位或   |
|       或非 | xor x5,x6,x7  | x5 = x6 ^ x7  | 三个寄存器操作：按位异或 |
|   与立即数 | andi x5,x6,20 | x5 = x6 & 20  | 和常数按位与             |
|   或立即数 | ori x5,x6,20  | x5 = x6 \| 20 | 和常数按位或             |
| 异或立即数 | xori x5,x6,20 | x5 = x6 ^ 20  | 和常数按位异或           |

#### 移位操作

|           指令 | 示例         | 含义          | 注释                     |
| -------------: | :----------- | :------------ | :----------------------- |
|       逻辑左移 | sll x5,x6,x7 | x5 = x6 << x7 | 按寄存器给定位数左移     |
|       逻辑右移 | srl x5,x6,x7 | x5 = x6 >> x7 | 按寄存器给定位数右移     |
|       算术右移 | sra x5,x6,x7 | x5 = x6 >> x7 | 按寄存器给定位数算数右移 |
| 逻辑左移立即数 | slli x5,x6,3 | x5 = x6 << 3  | 按立即数给定位数左移     |
| 逻辑右移立即数 | srli x5,x6,3 | x5 = x6 >> 3  | 按立即数给定位数右移     |
| 算术右移立即数 | srai x5,x6,3 | x5 = x6 >> 3  | 按立即数给定位数算数右移 |

#### 条件分支

|                     指令 | 示例           | 含义                               | 注释                                                     |
| -----------------------: | :------------- | :--------------------------------- | :------------------------------------------------------- |
|               相等即跳转 | beq x5,x6,100  | if (x5 == x6) <br />go to PC + 100 | 若寄存器数值相等则跳转到PC相对地址                       |
|               不等即跳转 | bne x5,x6,100  | if (x5 != x6) <br />go to PC + 100 | 若寄存器数值不等则跳转到PC相对地址                       |
|               小于即跳转 | blt x5,x6,100  | if (x6 < x7)<br />go to PC + 100   | 若寄存器数值比较结果小于则跳转到PC相对地址               |
|           大于等于即跳转 | bge x5,x6,100  | if (x6 >= x7)<br />go to PC + 100  | 若寄存器数值比较结果大于等于则跳转到PC相对地址           |
|     小于即跳转【无符号】 | bltu x5,x6,100 | if (x6 >= x7)<br />go to PC + 100  | 若寄存器数值比较结果小于则跳转到PC相对地址【无符号】     |
| 大于等于即跳转【无符号】 | bgeu x5,x6,100 | if (x6 >= x7)<br />go to PC + 100  | 若寄存器数值比较结果大于等于则跳转到PC相对地址【无符号】 |

#### 无条件跳转

|          指令           |     示例     |            含义             | 注释                     |
| :---------------------: | :----------: | :-------------------------: | :----------------------- |
|        跳转-链接        |   jal 2500   |   x1 = PC + 4; go to 100    | 用于过程调用             |
| 跳转-链接【寄存器地址】 | jalr 100(x5) | x1 = PC + 4; go to x5 + 100 | 用于过程返回，非直接调用 |

### <span id="指令格式">RISC-V六种指令格式</span>

#### R型：算输指令格式

|  字段  | 位数 | 比特位位置 | 注释                               |
| :----: | :--: | :--------: | :--------------------------------- |
| funct7 |  7   |   31:25    | 另外的操作码字段                   |
|  rs2   |  5   |   24:20    | 第二个源操作数寄存器               |
|  rs1   |  5   |   19:15    | 第一个源操作数寄存器               |
| funct3 |  3   |   14:12    | 另外的操作码字段                   |
|   rd   |  5   |    11:7    | 目的寄存器，用于存放操作结果       |
| opcode |  7   |    6:0     | 操作码，用于表示指令操作和指令格式 |

##### 常用

|          指令 | funct7  | rs2  | rs1  | funct3 | rd   | opcode  |
| ------------: | :------ | :--- | ---- | ------ | ---- | ------- |
|           add | 0000000 | reg  | reg  | 000    | reg  | 0110011 |
| sub[subtract] | 0100000 | reg  | reg  | 000    | reg  | 0110011 |
|           sll | 0000000 | reg  | reg  | 001    | reg  | 0110011 |
|           xor | 0000000 | reg  | reg  | 100    | reg  | 0110011 |
|           srl | 0000000 | reg  | reg  | 101    | reg  | 0110011 |
|           sra | 0000000 | reg  | reg  | 101    | reg  | 0110011 |
|            or | 0000000 | reg  | reg  | 110    | reg  | 0110011 |
|           and | 0000000 | reg  | reg  | 111    | reg  | 0110011 |
|          lr.d | 0001000 | reg  | reg  | 011    | reg  | 0110011 |
|          sc.d | 0001100 | reg  | reg  | 011    | reg  | 0110011 |

#### I型：加载&用于立即数

|      字段       | 位数 | 比特位位置 | 注释                                                         |
| :-------------: | :--: | :--------: | :----------------------------------------------------------- |
| immediate[11:0] |  12  |   31:20    | 字节偏移量或常数，可以取相对于基址rd偏移±2<sup>11</sup>个字节。 |
|       rs1       |  5   |   19:15    | 第一个源操作数寄存器                                         |
|     funct3      |  3   |   14:12    | 另外的操作码字段                                             |
|       rd        |  5   |    11:7    | 用于存放操作结果的目的寄存器                                 |
|     opcode      |  7   |    6:0     | 操作码，用于表示指令操作和指令格式                           |

##### 常用

|                指令 | immediate | rs1  | funct3 | rd   | opcode  |
| ------------------: | :-------- | :--- | ------ | ---- | ------- |
|                  lb | constant  | reg  | 000    | reg  | 0000011 |
|                  lh | constant  | reg  | 001    | reg  | 0000011 |
|                  lw | constant  | reg  | 010    | reg  | 0000011 |
|                  ld | constant  | reg  | 011    | reg  | 0000011 |
|                 lbu | constant  | reg  | 100    | reg  | 0000011 |
|                 lhu | constant  | reg  | 101    | reg  | 0000011 |
|                 lwu | constant  | reg  | 110    | reg  | 0000011 |
| addi[add immediate] | constant  | reg  | 000    | reg  | 0010011 |
|                slli | address   | reg  | 001    | reg  | 0000011 |
|                xori | -         | reg  | 100    | reg  | 0010011 |
|                srli | -         | reg  | 101    | reg  | 0010011 |
|                srai | -         | reg  | 101    | reg  | 0010011 |
|                 ori | constant  | reg  | 110    | reg  | 0010011 |
|                andi | constant  | reg  | 111    | reg  | 0010011 |
|                jalr | constant  | reg  | 000    | reg  | 1100111 |

#### S型：存储

|    字段     | 位数 | 比特位位置 | 注释                                                 |
| :---------: | :--: | :--------: | :--------------------------------------------------- |
| immed[11:5] |  7   |   31:25    | 字节偏移量，分两个位置存放，保证其他字段的位置不变化 |
|     rs2     |  5   |   24:20    | 第二个源操作数寄存器                                 |
|     rs1     |  5   |   19:15    | 第一个源操作数寄存器                                 |
|   funct3    |  3   |   14:12    | 另外的操作码字段                                     |
| immed[4:0]  |  5   |    11:7    | 字节偏移量，分两个位置存放，保证其他字段的位置不变化 |
|   opcode    |  7   |    6:0     | 操作码，用于表示指令操作和指令格式                   |

##### 常用

|                 指令 | immed[11:5] | rs2  | rs1  | funct3 | immed[4:0] | opcode  |
| -------------------: | :---------- | :--- | ---- | ------ | ---------- | ------- |
|                   sb | address     | reg  | reg  | 000    | address    | 0100011 |
|                   sh | address     | reg  | reg  | 001    | address    | 0100011 |
|                   sw | address     | reg  | reg  | 010    | address    | 0100011 |
| sd[store doubleword] | address     | reg  | reg  | 011    | address    | 0100011 |

#### U型：大立即数格式

|     字段     | 位数 | 比特位位置 | 注释                               |
| :----------: | :--: | :--------: | :--------------------------------- |
| immed[31:12] |  20  |   31:12    | 大数的高 31 ~ 12 位                |
|      rd      |  5   |    11:7    | 用于存放操作结果的目的寄存器       |
|    opcode    |  7   |    6:0     | 操作码，用于表示指令操作和指令格式 |

##### 常用

| 指令 | immed[31:12] | rd   | opcode  |
| ---: | :----------- | :--- | ------- |
|  lui | address      | reg  | 0110111 |

#### SB型：条件分支格式

> 不能编码奇数字地址

|      字段      | 位数 | 比特位位置 | 注释                                                 |
| :------------: | :--: | :--------: | :--------------------------------------------------- |
| immed[12,10:5] |  7   |   31:25    | 字节偏移量，分两个位置存放，保证其他字段的位置不变化 |
|      rs2       |  5   |   24:20    | 第二个源操作数寄存器                                 |
|      rs1       |  5   |   19:15    | 第一个源操作数寄存器                                 |
|     funct3     |  3   |   14:12    | 另外的操作码字段                                     |
| immed[4:1,11]  |  5   |    11:7    | 字节偏移量，分两个位置存放，保证其他字段的位置不变化 |
|     opcode     |  7   |    6:0     | 操作码，用于表示指令操作和指令格式                   |

##### 常用

| 指令 | immed[12,10:5] | rs2  | rs1  | funct3 | immed[4:1,11] | opcode  |
| ---: | :------------- | :--- | ---- | ------ | ------------- | ------- |
|  beq | address        | reg  | reg  | 000    | address       | 1100111 |
|  bne | address        | reg  | reg  | 001    | address       | 1100111 |
|  blt | address        | reg  | reg  | 100    | address       | 1100111 |
|  bge | address        | reg  | reg  | 101    | address       | 1100111 |
| bltu | address        | reg  | reg  | 110    | address       | 1100111 |
| bgeu | address        | reg  | reg  | 111    | address       | 1100111 |

#### UJ型：无条件跳转

|       字段        | 位数 | 比特位位置 | 注释                               |
| :---------------: | :--: | :--------: | :--------------------------------- |
| immed[20,10:1,11] |  12  |   31:20    | 地址位置，分两个位置存放           |
|   immed[19:12]    |  8   |   19:12    | 地址位置，分两个位置存放           |
|        rd         |  5   |    11:7    | 基址地址寄存器                     |
|      opcode       |  7   |    6:0     | 操作码，用于表示指令操作和指令格式 |

##### 常用

| 指令 | immed[20,10:1,11] | immed[19:12] | rd   | opcode  |
| ---: | :---------------- | :----------- | ---- | ------- |
|  jal | address           | address      | reg  | 1101111 |

## C程序

### 翻译并执行

```mermaid
graph LR
A[C程序语言] --> |编译器| B[汇编程序语言]
B --> |汇编器| C[目标模块: 机器语言模块]
C --> |链接器| E[可执行代码: 机器语言程序]
D[目标库: 机器语言模块] --> |链接器| E
E --> |加载器| F[存储器]
```

- **编译器**：将c语言转换成机器能理解的符号形式的汇编语言。
- **汇编语言**：一种符号语言，能被翻译成二进制的机器语言。
  - **伪指令**：汇编语言指令的变种通常被看作一条汇编指令。
- **汇编器**：汇编器能够处理一些机器语言指令的变种。这些变种也称为伪指令，简化了程序转换和编程。
- **目标文件**：机器代码语言。包括机器语言指令、数据和指令正确放入内存所需要的信息。
  - *目标文件头*：描述目标文件其他部分的大小和位置。
  - *代码段*：包含机器语言代码。
  - *静态数据段*：包含在程序生命周期内分配的数据。
  - *重定位信息*：标记了一些在程序加载进内存时依赖于绝对地址的指令和数据。**比如载入、跳转等包含address的指令**。
  - *符号表*：用来匹配标记名和指令所在内存字的地址的列表。包含未定义的剩余标记，如外部引用。**变量和分支等**。
  - *调试信息*：包含一份说明目标模块如何编译的简明描述。
- **链接器**：也称链接编辑器，系统程序。把各个独立汇编的机器语言程序组合起来并且解决所有未定义的标记，最终生成可执行文件。
  - **工作内容**
    - 使用每个目标模块中的重定位信息和符号表，解析所有的未定义标签。
      - 寻找所有旧地址并用新地址替换。
    - 外部引用解析完后，决定每个模块要占用的内存位置，当模块放入内存中时，修改重定位信息中的决定引用。
  - **工作步骤**
    - 将代码和数据模块象征性的放入内存。
    - 决定数据和指令标签的地址。
    - 修补内部和外部引用。
- **可执行文件**：具有目标文件格式的功能程序，不包含未解决的引用。可以包含符号表和调试信息。
- **加载器**：把目标程序装载到内存中以准备运行的系统程序。
  - 读取可执行文件头来确定代码段和数据段的大小。
  - 为正文和数据创建一个足够大的地址空间。
  - 将可执行文件中的指令和数据复制到内存中。
  - 把主程序的参数复制到栈顶。
  - 初始化机器寄存器，将栈指针指向第一个空位置。
  - 跳转到启动例程，将参数复制到参数寄存器并调用程序的main函数。当main函数返回时，启动例程通过系统调用exit终止程序。
- **动态链接库**：**DDL**，dynamically linked library。在程序执行过程中才被链接的库例程。
  - 第一次，调用虚入口。执行间接跳转，跳转到动态链接器或加载器。加载完在该表间接跳转位置的地址。
  - 以后，调用虚入口。间接跳转到例程。
- **内存分配**：<img src="./imgs/程序内存分配.png" alt="程序内存分配" style="zoom:50%;" />

### 边界检查

```assembly
# x20 >= x11 或者 x20 < 0，就跳到越界，可以让x11作为边界最大值
bgeu x20 x11 IndexOutOfBounds
```

### 函数

#### 运行步骤

1. 将参数放在过程可以访问的位置。
2. 将控制转交给过程。
3. 获得过程所需的存储资源。
4. 执行需要的任务。
5. 将结果的值放在调用程序可以访问的位置。
6. 将控制返回初始点，因为一个过程可能由一个程序的多个点调用。

#### 寄存器栈

- **过程调用保留**。

  | 保留                           | 不保留                       |
  | ------------------------------ | ---------------------------- |
  | 保存寄存器：x8 ~ x9, x18 ~ x27 | 临时寄存器：x5~x7, x28 ~ x31 |
  | 栈指针寄存器：x2(sp)           | 参数/结果寄存器：x10 ~ x17   |
  | 帧指针寄存器：x8(fp)           |                              |
  | 返回地址寄存器：x1(ra)         |                              |
  | 栈指针以上的栈                 | 栈指针以下的栈               |

- **参数过多**：前8个放在寄存器，其他的放在帧指针上方。

### 编译程序

#### 排序

- **c程序**

  ```c
  void sort(int v[], int n) {
      int i, j;
      for (i = 0; i < n; i++) {
          for (j = i - 1; j >= 0 && v[j] > v[j+1]; j--) {
              swap(v, j);
          }
      }
  }
  
  void swap(int v[], int k) {
      temp = v[k];
      v[k] = v[k + 1];
      v[k + 1] = temp;
  }
  ```

- **编译程序**

  ```assembly
  # v 和 n 使用参数寄存器，因为非叶程序，i 和 j 使用保存寄存器。
  # v -> x10; n -> x11; i -> x19; j -> x20;
  
  # 非叶程序，第一步：入栈，程序中用到了哪些寄存器，就要把寄存器的值入栈。
  		addi sp, sp, -40
  		sw x1, 32(sp)
  		sw x22, 24(sp)
  		sw x21, 16(sp)
  		sw x20, 8(sp)
  		sw x19, 0(sp)
  
  # sort 过程体
  # 复制参数，因为调用swap函数需要用到参数寄存器，所以要先移过来。
  		mv x21, x10
  		mv x22, x11
  
  # 外层循环
  		li x19, 0									# i = 10
  loop1:	bge x19, x22, exit1  	# i >= n
  		
  # 内层循环
  		addi x20, x19, -1 				# j = i - 1
  loop2:	blt x20, x0, exit2 		# j < 0
  		slli x5, x20, 3 					# j << 2
  		add x5, x5, x21 					# v[j]基址
  		ld x6, 8(x5) 							# v[j]
  		ld x7, 8(x5) 							# v[j+1]
  		ble x7, x6, exit2 				# v[j+1] < v[j]
  		
  # 传参和调用
  		mv x10, x21								# 参数赋值
  		mv x11, x20								# 参数赋值
  		jal x1, swap 							# 跳转swap(v[], k) 并修改x1
  		
  # 循环内部
  		addi x20, x20, -1 				# j--
  		j loop2
  
  exit2:	addi x19, x19, 1 			# i++
  		j loop1
  
  # 恢复寄存器的值
  exit1:	lw x19, 0(sp)
  		lw x20, 8(sp)
  		lw x21, 16(sp)
  		lw x22, 24(sp)
  		lw x1, 32(sp)
  		addi sp, sp, 40
  		
  # 过程返回
  		jalr x0, 0(x1)
  		
  # swap函数
  swap:	sll x5, x11, 2
  		add x5, x10, x5
  		lw x5, 0(x5)
  		lw x5, 4(x5)
  		sw x5, 0(x5)
  		sw x5, 4(x5)
  		jr x1

#### 矩阵乘法

- **c程序**

  ```c
  // 前提，矩阵都是32 * 32
  void mm(double c[][], double a[][], double b[][]) {
      int i, j, k;
      for(i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
              for(k = 0; k < 32; k++) {
                  c[i][j] += a[i][k] * b[k][j];
              }
          }
      }
  }
  ```

- **编译程序**

  ```assembly
  # 寄存器入栈
  mm:		addi sp, sp, -16
  		sw x1, 12(sp)
  		sw x21, 8(sp)
  		sw x20, 4(sp)
  		sw x19, 0(sp)
  
  		addi x5, x0, 32		# 将32给到临时变量
  		add x19, x0, x0	# i = 0
  		
  loop1:	add x20, x0, x0	# j = 0
  
  loop2:	add x21, x0, x0	# k = 0
  		sll $t₂, x19, 5			# 得到[i][0]字偏移量
  		addu $t₂, $t₂, x20		# 得到[i][j]字偏移量
  		sll $t₂, $t₂, 3			# 得到字节偏移量，又因为每个元素占2字节，所以 * 4 * 2
  		addu $t₂, x10, $t₂		# 得到c[i][j]基址
  		l.d $f₄, 0($t₂)			# 从基址处获取8个字节，存在$f₃ ~ $f₄中
  		
  loop3:	sll x5, x21, 5			# 得到[k][0]字偏移量
  		addu x5, x5, x20		# 得到[k][j]字偏移量
  		sll x5, x5, 3			# 得到字节偏移量，又因为每个元素占2字节，所以 * 4 * 2
  		addu x5, $a₂, x5		# 得到b[k][j]基址
  		l.d $f₁₆, 0(x5)		
  		
  		sll x5, x19, 5			# 得到[i][0]字偏移量
  		addu x5, x5, x21		# 得到[i][k]字偏移量
  		sll x5, x5, 3			# 得到字节偏移量，又因为每个元素占2字节，所以 * 4 * 2
  		addu x5, x11, x5		# 得到a[i][k]基址
  		l.d $f₁₈, 0(x5)		
  		
  # 乘法
  		mul.d $f₁₆, $f₁₈, $f₁₆
  		add.d $f₄, $f₄, $f₁₆
  		
  		addiu x21, x21 1 		# k = k + 1
  		bne x21, x5, loop3
  		s.d $f₄, 0($t₂)
  		
  		addiu x20, x20, 1		# j = j + 1
  		bne x20, x5, loop2
  		
  		addiu x19, x19, 1		# j = j + 1
  		bne x19, x5, loop1
  		
  # 恢复寄存器
  		lw x19, 0(sp)
  		lw x20, 4(sp)
  		lw x21, 8(sp)
  		lw x1, 12(sp)
  		addi sp, sp, 16
  		jr x1
  ```

## JAVA程序

todo 老孙

## 并行与同步

- **数据竞争**：来自不同线程的两个访存请求访问同一个地址，连续出现，并且其中一个是写操作，存储访问形成数据竞争。
- **原子交换原语**：提供对存储单元进行原子读和原子写的能力，多处理器中实现同步需要，存储器在进行原子度或原子写操作时任何其他操作都不得插入。

- **原子操作实现**：指令对，如果保留加载指令指定的内存位置的内容在条件存储指令执行到同一位置时发生了变化，则条件指令存储失败且不会将值写入内存。
  - 保留加载：`lr.d`
  - 条件存储：`sc.d`

# 数据通路

- **谬误**：左移可以代替2的幂次方数相乘，右移也可以代替与2的幂次方数相除。**无符号整数可以，有符号整数有问题**。
- **陷阱**：浮点加法不能使用结合律。**因为浮点数精度有限，结合可能会导致精度提前忽略**。
- **谬误**：并行执行策略不但适用于整数类型数据，同样也适用于浮点数据类型。**因为浮点数不能使用结合律**。
- **谬误**：只有理论数学家才会关心浮点精度。

## 相关指令

### 算数

|                     指令 | 示例              | 含义                                   | 注释                       |
| -----------------------: | :---------------- | :------------------------------------- | :------------------------- |
|                 小于置位 | slt x5,x6,x7      | if (x6 < x7) x5 == 1<br />else x5 == 0 | 三个寄存器操作数           |
|     小于置位【无符号数】 | sltu x5,x6,x7     | if (x6 < x7) x5 == 1<br />else x5 == 0 | 三个寄存器操作数           |
|       小于置位【立即数】 | slti x5,x6,x7     | if (x6 < x7) x5 == 1<br />else x5 == 0 | 与立即数比较               |
| 小于置位【无符号立即数】 | sltiu x5,x6,x7    | if (x6 < x7) x5 == 1<br />else x5 == 0 | 与立即数比较               |
|                       乘 | mul x5,x6,x7      | x5 = x6 * x7                           | 128位乘积的低64位          |
|                   高位乘 | mulh x5,x6,x7     | x5 = (x6 * x7) >> 64                   | 128位有符号乘积的高64位    |
|       高位乘【无符号数】 | mulhu x5,x6,x7    | x5 = (x6 * x7) >> 64                   | 128位无符号乘积的高64位    |
|    高位乘【有-无符号数】 | mulhsu x5,x6,x7   | x5 = (x6 * x7) >> 64                   | 128位有-无符号乘积的高64位 |
|                       除 | div x5,x6,x7      | x5 = x6 / x7                           | 取有符号64位数字           |
|             除【无符号】 | divu x5,x6,x7     | x5 = x6 / x7                           | 取无符号64位数字           |
|                     取余 | rem x5,x6,x7      | x5 = x6 % x7                           | 对有符号64位除法取余       |
|           取余【无符号】 | remu x5,x6,x7     | x5 = x6 % x7                           | 对无符号64位除法取余       |
|         浮点加【单精度】 | fadd.s f0, f1, f2 | f0 = f1 + f2                           |                            |
|         浮点减【单精度】 | fsub.s f0,f1,f2   | f0 = f1 - f2                           |                            |
|         浮点乘【单精度】 | fmul.s f0,f1,f2   | f0 = f1 * f2                           |                            |
|         浮点除【单精度】 | fdiv.s f0,f1,f2   | f0 = f1 / f2                           |                            |
|     浮点平方根【单精度】 | fsqrt.s f0,f1     | f0 = √f1                               |                            |
|         浮点加【双精度】 | fadd.d f0,f1,f2   | f0 = f1 + f2                           |                            |
|         浮点减【双精度】 | fsub.d f0,f1,f2   | f0 = f1 - f2                           |                            |
|         浮点乘【双精度】 | fmul.d f0,f1,f2   | f0 = f1 * f2                           |                            |
|         浮点除【双精度】 | fdiv.d f0,f1,f2   | f0 = f1 / f2                           |                            |
|     浮点平方根【双精度】 | fsqrt.d f0,f1     | f0 = √f1                               |                            |

### 比较

|                     指令 | 示例           | 含义                                    | 注释             |
| -----------------------: | :------------- | :-------------------------------------- | :--------------- |
|     浮点数相等【单精度】 | feq.s x5,f0,f1 | if (f0 == f1) x5 == 1<br />else x5 == 0 | 单精度浮点数比较 |
|     浮点数小于【单精度】 | flt.s x5,f0,f1 | if (f0 < f1) x5 == 1<br />else x5 == 0  | 单精度浮点数比较 |
| 浮点数小于等于【单精度】 | fle.s x5,f0,f1 | if (f0 <= f1) x5 == 1<br />else x5 == 0 | 单精度浮点数比较 |
|     浮点数相等【双精度】 | feq.d x5,f0,f1 | if (f0 == f1) x5 == 1<br />else x5 == 0 | 双精度浮点数比较 |
|     浮点数小于【双精度】 | flt.d x5,f0,f1 | if (f0 < f1) x5 == 1<br />else x5 == 0  | 双精度浮点数比较 |
| 浮点数小于等于【双精度】 | fle.d x5,f0,f1 | if (f0 <= f1) x5 == 1<br />else x5 == 0 | 双精度浮点数比较 |

### 数据传输

|       指令 | 示例         | 含义                | 注释                             |
| ---------: | :----------- | :------------------ | :------------------------------- |
|   浮点取字 | flw f0,4(x5) | f0 = Memory[x5 + 4] | 从存储器取单精度字到浮点寄存器   |
| 浮点取双字 | fld f0,8(x5) | f0 = Memory[x5 + 8] | 从存储器取双精度字到浮点寄存器   |
|   浮点存字 | fsw f0,4(x5) | Memory[x5 + 4] = f0 | 将浮点寄存器的单精度字存到存储器 |
| 浮点取双字 | fsd f0,8(x5) | Memory[x5 + 8] = f0 | 将浮点寄存器的双精度字存到存储器 |

## 整数

### 加减法

- **加法**：从右到左逐渐位相加，进位也向左传播。

  > 因此不必额外考虑符号的问题。

- **减法**：对数取补码后，执行加法操作。

- **溢出条件**

  | 操作  | 操作数A | 操作数B | 表示结果有溢出的条件 |
  | ----- | ------- | ------- | -------------------- |
  | A + B | >=0     | >=0     | <0                   |
  | A + B | <0      | <0      | >=0                  |
  | A - B | >=0     | <0      | <0                   |
  | A - B | <0      | >=0     | >=0                  |

- **算数异常**

  - add、addi、sub 在溢出时产生异常。
  - addu、addiu、subu在溢出时不产生异常。【C语言忽略溢出，所以使用这个指令。】

- **异常**：也叫中断，一种打断正常程序执行过程的事件，用于溢出检测。

  > 1. 产生异常的指令保存到寄存器【异常程序计数器，EPC，$k₀ ~ $k₁】中。
  > 2. 跳到预先设定好的地址执行异常处理程序。

- **饱和操作**：发生溢出时，结果被设置为最大正数或最小负数。

### 乘法

> 乘数为常数时，乘法会用移位来代替。编译器将短常数的乘法替换为一系列移位和加法。

- **硬件结构**：<img src="./imgs/乘法硬件结构.png" alt="乘法硬件结构" style="zoom:50%;" />

  > 积寄存器多一位是为了保存加法器的进位。

- **执行逻辑**

  ```mermaid
  graph TD
  A(开始) --> B[乘数 放入 积/乘数寄存器 的低64位]
  B -->C{检查 积/乘数寄存器 最低位}
  C --> |=1|D[积/乘数寄存器 高65位加上 被乘数,<br \>将结果写入 积/乘数寄存器 的高65位]
  D --> E[积/乘数寄存器 右移一位,<br \>相当于同时把 被乘数寄存器 左移和 乘数寄存器 右移]
  C --> |=0| E
  E --> F{第64次重复?}
  F --> |否| B
  F --> |是| G(结束)
  ```

  - **重复次数优化**：原来是加法器栈。并行树，log₂(64) = 6。

- **有符号乘法**

  - 将算法迭代63次，符号位不参与运算。

  - 符号位最后单独计算，符号相异时，符号位位1。


### 除法

- **硬件结构**：<img src="./imgs/除法硬件结构.png" alt="除法硬件结构" style="zoom:50%;" />

- **执行逻辑**：

  ```mermaid
  graph TD
  A(开始) --> B[将 被除数 放在 商/余数寄存器 的低65位]
  B --> C[从 商/余数寄存器 的低65位减去 除数寄存器 的值,将结果放在 商/余数寄存器 中]
  C --> D{测试余数}
  D --> |余数 >= 0|E[商/余数寄存器 左移<br \>相当于同时将 余数寄存器 左移和 除数寄存器 右移<br \>最低为设为1]
  D --> |余数 < 0| F[通过给 商/余数寄存器 加上 除数寄存器 来恢复原值,结果放在 余数寄存器.<br \>商/余数寄存器 左移0<br \>相当于同时将 余数寄存器 左移和 除数寄存器 右移<br \>最低为设为.]
  E --> G{第64次重复?}
  F --> G
  G --> |否| B
  G --> |是| H(结束)
  ```

- **有符号除法**

  - 源操作数的符号相反时商为负。

  - 使非零余数的符号和被除数相同。

## 浮点运算

|             指令 | 示例           | 含义                                          | 注释                     |
| ---------------: | :------------- | :-------------------------------------------- | :----------------------- |
|     取字【浮点】 | lw $f₁,40(x6)  | $f₁ = Memory[x6 + 40]                         | 将字从内存取到浮点寄存器 |
|     存字【浮点】 | lw $f₁,40(x6)  | Memory[x6 + 40] = $f₁                         | 将字从浮点寄存器存到内存 |
| 浮点标志真则跳转 | bclt 25        | if (cond == 1) <br />go to PC + 4 + 100       |                          |
| 浮点标志假则跳转 | bclf 25        | if (cond == 0) <br />go to PC + 4 + 100       |                          |
|   浮点单精度比较 | c.lt.s $f₂,$f₄ | if ($f₂ < $f₄) cond = 1;<br />else  cond = 0; |                          |
|   浮点双精度比较 | c.lt.d $f₂,$f₄ | if ($f₂ < $f₄) cond = 1;<br />else  cond = 0; |                          |

- **科学计数法**：十进制小数点左边只有一位整数的计数法。
- **规格化数**：没有前导0的浮点计数法。
  - 简化了浮点数的数据交换。
  - 简化了浮点算术运算。
  - 提高了一个字存储的数的精度。
- **浮点数**：二进制小数点不固定的表达数的计数法。

### 浮点表示

- **尾数**：位于浮点数的尾数字段，其值在0和1之间。

- **指数**：位于浮点数的指数字段，表示小数点的位置。

  - **指数正负**：偏阶计数法。单精度偏阶127，双精度1023。
    - 11111111：表示最大正数。
    - 00000000：表示最小负数。

- **溢出【上溢】**：正的指数太大而导致指数域放不下的情况。

- **下溢**：负的指数太大导致指数域放不下的情况。

- **双精度**：浮点数由两个32位的字表示。

  - | 符号位         | 指数 | 尾数 |
    | -------------- | ---- | ---- |
    | 1位，1代表负数 | 11位 | 52位 |

  - *表示对象*

    | 指数     | 尾数   | 表示对象  |
    | -------- | ------ | --------- |
    | 0        | 0      | 0         |
    | 0        | 非0    | ±非规格数 |
    | 1 ~ 2046 | 任何值 | ±浮点数   |
    | 2047     | 0      | ±无穷     |
    | 2047     | 非0    | NaN       |

- **单精度**：浮点数由一个32位的字表示。

  - | 符号位         | 指数 | 尾数 |
    | -------------- | ---- | ---- |
    | 1位，1代表负数 | 8位  | 23位 |

  - *表示对象*

    | 指数    | 尾数   | 表示对象    |
    | ------- | ------ | ----------- |
    | 0       | 0      | 0           |
    | 0       | 非0    | ±非规格化数 |
    | 1 ~ 254 | 任何值 | ±浮点数     |
    | 255     | 0      | ±无穷       |
    | 255     | 非0    | NaN         |

- **有效位**：有效位比尾数多了一个1，隐藏了规格化二进制数的前导位1。
- **非规格化数**：在指数为0而有效数非0时，允许一个有效数逐步变小直至0，称为**逐步下溢**。进而获得更大的精度。

#### 举例：-0.75表示

> -3 / 4 => -11/ 2² => -1.1 * 2<sup>-1</sup>
>
>  浮点数的尾数表示时去掉前导1。

- **单精度**

  | 符号位 | 指数     | 尾数                   |
  | ------ | -------- | ---------------------- |
  | 1      | 01111110 | 1000000000000000000000 |

- **双精度**

  | 符号位 | 指数        | 尾数                                              |
  | ------ | ----------- | ------------------------------------------------- |
  | 1      | 01111111110 | 1000000000000000000000000000000000000000000000000 |

### 加法

- **硬件结构**：<img src="./imgs/浮点数加法硬件结构.png" alt="浮点数加法硬件结构" style="zoom:35%;" />

- **执行逻辑**

  ```mermaid
  graph TD
  A(开始) --> B[比较两个数的指数,将指数最小的数进行右移,直到其指数与指数较大的相匹配]
  B --> C[尾数相加]
  C --> D[结果进行规格化,右移时增大指数,左移时减小指数]
  D --> E{上溢或下溢}
  E --> |是| F(异常)
  E --> |否| G[对尾数进行舍入,保留适当的位数]
  G --> H{依然是规格化数?}
  H --> |是| I(结束)
  H --> |否| D
  ```

### 乘法

- **执行逻辑**

  ```mermaid
  graph TD
  A(开始) --> B[对两个偏阶指数相加,然后减去偏阶值,得到新的偏阶指数]
  B --> C[尾数相乘]
  C --> D[如有需要,对乘积进行规格化:乘积右移,指数增大]
  D --> E{上溢或下溢}
  E --> |是| F(异常)
  E --> |否| G[对尾数进行舍入,保留适当的位数]
  G --> H{依然是规格化数?}
  H --> |否| D
  H --> |是| I[如果操作数符号相同,设置积的符号为正,否则为负]
  I --> J(结束)
  ```

### 算数精确性

> 中间计算中右边多保留两位。0~49舍，51~99入。

- **保护位**：在浮点数中间计算中，在右边多保留的两位中的首位；用于提高舍入精度。

- **舍入位**：在浮点数中间计算中，在右边多保留的两位中的第二位；使浮点中间结果满足浮点格式，得到最接近的数。
- **尾数最低位**：在实际数和能表达的数之间的有效数最低位上的误差位数。

## 子字并行

在一个宽字内部进行的并行操作。

- 通过提供256字节的寄存器实现。
- 100多条宽字指令。

### 举例

矩阵相乘可以每4个为一组在一个宽字上运算，速度可以提升4倍。

# 处理器

- **谬误**：流水线是简单的。

  > Inter Core i7的流水线结构，仅Verlog代码就有成千上万行。

- **谬误**：对于流水线等结构设计，可以与工艺无关。

  > 晶体管数量成倍增长，处理速度远超存储，多个功能部件和动态流水线技术也越来越关键。

- **陷阱**：缺乏对指令系统设计的考虑反过来会影响流水线的实现。

- 

## 名词解释

- **逻辑单元**
  - **组合单元**：操作单元，如与门或ALU。
  - **状态单元**：存储单元，如寄存器个存储器。至少有两个输入和一个输出。
    - **两个输入**：**要写入的数据值**、**时钟信号**。
    - **一个输出**：在前一个时钟信号写入单元的数据值。
    - **写控制信号**
      - **需要**：状态单元在每个有效的时钟边沿都进行写操作。
      - **不需要**：状态单元不是在每个有效的时钟边沿【当前基于上升沿】都进行写操作。
  
- **控制信号**：用来决定多选器选择或指示功能单元操作的信号；与数据信号相对应，数据信号包含由功能单元操作的信息。
  - **有效**：表示信号为逻辑高或真。
  - **无效**：表示信号为逻辑低或假。
  - 在硬件实现时，**数字1有时表示逻辑高，有时表示逻辑假**。
  
- **时钟方法**：用来确定数据相对于时钟何时稳定和有效的方法。
  - **边沿触发的时钟**：一种所有的状态改变发生于时钟沿的时钟机制。
  
- **数据通路部件**：一个用来操作或保存处理器中数据的单元。在MIPS实现中，数据通路部件包含**指令存储器**、**数据存储器**、**寄存器堆**、**ALU**和**加法器**。

  - **程序计数器**：PC，存放下一条将要被执行指令地址的寄存器。
  - **寄存器堆**：包含一系列寄存器的状态单元，可以通过寄存器号进行读写。
  - **符号扩展**：处理偏移地址需要，为增加数据项的长度，将原数据项的最高位复制到新数据项多出来的高位。

- **流水线技术**：在顺序指令流中开发指令间并行的技术。**提高吞吐率**。

  - **流水线冒险**：在下一时钟周期下一条指令无法执行。

    - **结构冒险**：因缺乏硬件支持而导致指令不能在预定时间周期内执行。【例如指令存储器和数据存储器是从同一存储器内取数据】。

    - **数据冒险**：因无法提供指令执行所需数据而导致指令不能在预先的时间周期内执行。**严重浪费**。

      ```assembly
      add x19, x1, x0
      sub x2, x19, x13
      ```

    - **控制冒险**：也称为分支冒险，由于取到的指令并不是所需要的，或者指令地址的流向不是流水线所预期的没导致正确的指令无法在正确的时钟周期内执行。

      - **停顿**：取出分支指令后立即停顿，等到流水线确定分支。
      - **分支预测**：一种解决分支冒险的方法。它预测分支的结果并沿预测方向执行，而不等分支结果确定后再开始执行。
      - **延迟转移**：在分支指令后放一条不受分支影响的指令。**将分支前面的指令移到分支后执行**。

  - **前递或旁路**：一种解决数据冒险的方法，提前从内部缓冲中拿到数据，而不是等到数据到达程序员可见的寄存器或存储器。**不能避免所有流水线停顿**。

  - **载入-使用型数据冒险**：一种特定形式的数据冒险，指当载入指令要取的数据还没取回时，其他指令就需要该数据的情况。

  - **流水线停顿**：也称为气泡，为了解决冒险而实施的一种阻塞。

  - **空指令**：流水线停顿的实现。一种不执行任何操作、不改变任何状态的指令。
  
- **异常**：也称为中断，指打断程序正常执行的突发事件，比如未定义指令。

- **中断**：来次处理器外部的异常。

- **指令级并行**：指令间的并行性。

  - **多发射**：一个时钟周期内可以发射多条指令的策略。
    - **静态多发射**：多发射的一种实现方式，由编译器完成发射相关判断。
    - **动态多发射**：多发射的一种实现方式，在动态执行过程中由硬件完成发射相关判断。


## 单周期指令设计

> - 从一个时钟边沿开始执行，下一个时钟边沿完成执行。
> - 任何数据通路单元都只能使用一次，所以分开了指令存储器和数据存储器。
> - **现在不使用单周期的原因**：违反了**加速经常性事件**原则。处理器的最长路径决定了时钟周期，时钟周期过长，会导致整体性能变差。

### 实现内容

- **存储器访问指令**：`存字【lw】`、 `取字【sw】`。
- **算数逻辑指令**：`加法【add】`、`减法【sub】`、`与【and】`、`或【or】`。
- **条件分支指令**：`相等则跳转【beq】`。

### 执行过程

- `add x1, x2, x3`

  > 1. 从指令寄存器取出指令，PC自增。
  > 2. 从寄存器堆读出两个寄存器 x2 和 x3，主控制单元在此步骤计算控制信号。
  > 3. 根据部分操作码确定ALU的功能，对寄存器对读出的数据进行操作。
  > 4. 将ALU的结果写入寄存器堆的目标存储器x1。

- `ld x1, offset(x2)`

  > 1. 从指令寄存器取出指令，PC自增。
  > 2. 从寄存器堆读出寄存器 x2 的值。
  > 3. ALU将从寄存器堆中读出的值和符号扩展后的指令中12位偏移量相加。
  > 4. 将ALU的结果用作数据存储器的地址。
  > 5. 将存储器读出的数据写入寄存器堆 x1。

- `beq x1, x2, offset`

  > 1. 从指令寄存器取出指令，PC自增。
  > 2. 从寄存器堆读出两个寄存器 x1 和 x2。
  > 3. ALU将从寄存器中读出的两数相减。PC与左移一位&符号扩展后的指令中的12位相加，结果是分支目标地址。
  > 4. ALU的零输出决定将哪个加法器的结果写入PC。

### 数据通路

> 默认每个状态单元都有时钟信号。

<img src="./imgs/单周期指令设计.png" alt="单周期指令设计" style="zoom:50%;" />

#### 组件

- **指令存储器**：只读的，也可以认为是组合逻辑。

- **程序计数器**：每个时钟周期都会写入，不需要写信号控制。

- **加法器**

  - **程序计数器自增**：+4。

  - **PC相对寻址**

    > - 指令系统体系结构规定：计算分支目标地址的基址是分支指令所在地址。
    > - 计算分支目标地址时，将偏移量左移一位表示以半字为单位的偏移量，这样偏移量的有效范围可以扩大两倍。
    > - **因此**，需要将偏移量再左移一位，表示字节位置，然后再加上PC地址。

- **数据存储器**：有地址输入和写数据输入，以及读取结果的单个输出。读、写控制信号相互独立，但仅有一个可以在任意给定的时钟上有效。

- **符号扩展单元**：用于将地址扩展成64位数字，用于计算。

- **寄存器**

  > - 对于R型和和分支指令：第一个操作数始终在 15 ~ 19 位。也定义载入和存储指令的基址寄存器。
  > - 对于R型和和分支指令：第二个操作数始终在 20 ~ 24 位。也可以定义存储指令中的寄存器，保存了写入存储器中的操作数。
  > - 对于分支指令、载入指令和存储指令，另一个操作数可以是12位立即数。
  > - 对于R型指令和载入指令，目标寄存器始终在 7 ~ 11 位。

- **opcode控制器**

  - **opcode与信号真值表**

    | 指令 | opcode  | ALUSrc | MemtoReg | RegWrite | MemRead | MemWrite | Branch | ALUOp |
    | ---: | ------- | ------ | -------- | -------- | ------- | -------- | ------ | ----- |
    |  R型 | 0110011 | 0      | 0        | 1        | 0       | 0        | 0      | 10    |
    |   ld | 0000011 | 1      | 1        | 1        | 0       | 0        | 0      | 00    |
    |   sd | 0100011 | 1      | X        | 0        | 0       | 1        | 0      | 00    |
    |  beq | 1100011 | 0      | X        | 0        | 0       | 0        | 1      | 01    |

  - **1位信号**

    |   信号名 | 无效时的效果【置0】                                          | 有效时的效果【置1】                                          |
    | -------: | ------------------------------------------------------------ | ------------------------------------------------------------ |
    |   ALUSrc | 第二个ALU操作数来自第二个寄存器的输出<br />即读数据2信号输出 | 第二个ALU操作数是指令的低12位符号扩展                        |
    | MemtoReg | 寄存器写数据的输入值来自于AlU                                | 寄存器写数据的输入值来自于数据存储器                         |
    | RegWrite | 无                                                           | 被写的寄存器号来自于写寄存器信号的输入<br />数据来自写数据的输入 |
    |  MemRead | 无                                                           |                                                              |
    | MemWrite | 无                                                           |                                                              |
    |   Branch | PC的值由PC + 4 替代                                          | 当ALU零输出有效时，PC的值由分支目标地址替代                  |

  - **两位信号**：**ALUOp**，指明要进行的操作。

    | ALUOp | 功能               |
    | ----: | ------------------ |
    |    00 | 存取指令需要的加法 |
    |    01 | beq需要的减法      |
    |    10 | 由 funct 字段决定  |

- **ALU控制器**

  - **funct和ALUOp的真值表**

    | ALUOp | funct7字段 | funct3字段 | 操作【结果】 |
    | ----- | ---------- | ---------- | ------------ |
    | 00    | x          | x          | 0010         |
    | x1    | x          | x          | 0110         |
    | 1x    | 0000000    | 000        | 0010         |
    | 1x    | 0100000    | 000        | 0110         |
    | 1x    | 0000000    | 111        | 0000         |
    | 1x    | 0000000    | 110        | 0001         |

  - **输出：ALU控制信号**

    | ALU控制信号 | 功能 |
    | ----------: | ---- |
    |        0000 | 与   |
    |        0001 | 或   |
    |        0010 | 加   |
    |        0110 | 减   |

## 流水线指令设计

- 任何指令都要经过流水线的每一阶段。

### 五级流水线&流水线寄存器

```mermaid
graph LR
A[IF<br />instruction fetch<br />取指令] --> |IF/ID寄存器| B[ID<br />instruction docode/register read<br />指令译码, 读寄存器堆]
B --> |ID/EX寄存器| C[EX<br />ALU execute<br />执行或计算地址]
C --> |EX/MEM寄存器| D[MEM<br />memory access<br />存储数据访问]
D --> |MEM/WB寄存器| E[WB<br />write black<br />写回]
```

### 多时钟周期流水线图

<img src="./imgs/多时钟流水线.png" alt="多时钟流水线" style="zoom:50%;" />

### 数据通路

<img src="./imgs/流水线指令设计.png" alt="流水线指令设计" style="zoom:200%;" />

#### 流水线控制

| 流水线级别             | 寄存器 | 控制                              | 标识 | 描述                                                         |
| ---------------------- | ------ | --------------------------------- | ---- | ------------------------------------------------------------ |
| 取址                   | -      | 无特别控制                        | -    | 写PC控制信号、读存储器信号总有效                             |
| 指令译码<br />读存储器 | IF/ID  | 无特别控制                        | -    | 源寄存器总是在相同位置                                       |
| 执行/地址计算          | ID/EX  | ALUOp<br />ALUSrc                 | EX   | ALUOp：和 funct字段一起决定ALU操作。<br />ALUSrc：决定ALU的第二个输入是寄存器2还是符号扩展数。 |
| 存储器访问             | EX/MEM | Branch<br />MemRead<br />MemWrite | M    | Branch：控制PCSrc的值，决定PC的写回值。<br />MemRead：存储器读信号。<br />MemWrite：存储器写信号。 |
| 写回                   | MEM/WB | MemToReg<br />RegWrite            | WB   | MemToReg：决定将ALU结果或者存储器值写回寄存器。<br />RegWrite：写入寄存器信号。 |

#### 数据冒险

##### 旁路与前递

###### 冒险情况

> 通过寄存器号来判断。

| 冒险情况 | 条件<br />第一部分是寄存器名称，第二部分是字段名称 | 描述                                                         |
| -------- | -------------------------------------------------- | ------------------------------------------------------------ |
| 1a       | EX/MEM.RegisterRd = ID/EX.RegisterRs1              | <img src="./imgs/1a数据冒险.png" alt="1a数据冒险" style="zoom:40%;" /> |
| 1b       | EX/MEM.RegisterRd = ID/EX.RegisterRs2              | 同1a                                                         |
| 2a       | MEM/WB.RegisterRd = ID/EX.RegisterRs1              | 同2b                                                         |
| 2b       | MEM/WB.RegisterRd = ID/EX.RegisterRs2              | <img src="./imgs/2b数据冒险.png" alt="2a数据冒险" style="zoom:40%;" /> |

- **WB级的冒险由寄存器堆实现复杂旁路。**

###### 冒险输出信号

> 可以在ALU输入时增加两个多选控制器来决定输入的值。

| 多选器       | 多选器信号 | 源     | 解释                                                         |
| ------------ | ---------- | ------ | ------------------------------------------------------------ |
| Forward[A/B] | 00         | ID/EX  | 第【一/二】个ALU操作数来自寄存器堆                           |
| Forward[A/B] | 10         | EX/MEM | 第【一/二】个ALU操作数由上一个ALU运算结果旁路获得            |
| Forward[A/B] | 01         | MEM/WB | 第【一/二】个ALU操作数从数据存储器或者前面的ALU结果旁路中获得。 |

###### 冒险信号算法

- **EX冒险**

  ```c
  if (
      EX/MEM.RegWrite 
      and (EX/MEM.RegisterRd != 0) 
      and (EX/MEM.RegisterRd == ID/EX.RegisterRs[1|2])
  )
      Forward[A|B] = 10
  ```

- **MEM冒险**

  ```c
  if (
  	MEM/WB.RegWrite 
  	and (MEM/WB.RegisterRd != 0) 
      and (MEM/WB.RegisterRd == ID/EX.RegisterRs[1|2])
  )
  	Forward[A|B] = 01
  ```

  - **特殊情况**

    ```assembly
    add x1, x1, x2
    add x1, x1, x3
    add x1, x1, x4
    ```

    > 此时第三个add 应该用第二个add的ALU输出而不是第一个的ALU输出。

    ```c
    if (
    	MEM/WB.RegWrite 
    	and (MEM/WB.RegisterRd != 0) 
    	and not(
        	EX/MEM.RegWrite 
        	and (EX/MEM.RegisterRd != 0) 
       		and (EX/MEM.RegisterRd == ID/EX.RegisterRs[1|2])
       	)
        and (MEM/WB.RegisterRd == ID/EX.RegisterRs[1|2])
    )
    	Forward[A|B] = 01
    ```

##### 停顿

###### 冒险情况

当一条指令试图读取一个由前一条装载指令读入的寄存器无法使用旁路解决数据冒险。

<img src="./imgs/数据冒险停顿.png" alt="数据冒险停顿" style="zoom:80%;" />

###### 停顿方式

1. 加入冒险检测单元，工作在ID级运行前。检测方式详见：**冒险检测**。
2. 保持当前指令向后不再执行，方式是加入**空指令**，可以将所有控制信号都置为0【所有的寄存器和存储器都不进行写操作】。
3. 保持 PC寄存器 和 **IF/ID寄存器** 的值不变，让当前指令重新执行IF阶段。

<img src="./imgs/数据冒险停顿方式.png" alt="数据冒险停顿方式" style="zoom:80%;" />

###### 冒险检测

```c
if (
    ID/EX.MemRead 
    and (
        (ID/EX.RegisterRd == IF/ID.RegisterRs1)
    	or (ID/EX.RegisterRd == IF/ID.RegisterRs2)
    )
)
    // 停一下
```

#### 控制冒险

##### 缩短分支延迟

- 将计算从 EX级 提到 ID级。
  - 计算分支目标地址。
  - 判断分支条件。

- 只需要清除后面一条指令，加入IF.Flush控制信号，将指令字段置0。

##### 动态分支预测

>  通过 **分支预测缓存** 查找指令的地址观察上一次上一次执行该指令时分支是否发生。

- **分支预测缓存**：分支历史表，按照分支指令的低位地址定位的小容量存储器，包含一个或多个比特以表明一个分支最近是否发生了跳转。

## 指令级并行【ILP】

- **提高指令级并行度的方法**
  - 增加流水线级数。
  - **多发射**：增加流水线内部的功能数量，一个时钟周期内可以发射多条指令。

# 存储器

## 名词解释

- **局部性原理**：principle of locality。
  - **时间局部性**：如果某个数据项被访问，那么在不久的将来它可能再次被访问。
  - **空间局部性**：如果某个数据项被访问，与它地址相邻的数据项可能很快也被访问。
- **存储器层次结构**：多级存储采用的结构，与处理器的距离越远，存储的容量越大，访问速度越慢。
  - **块或行**：在缓存中存储信息的最小单位。
  - **命中【hit】**：处理器所需的数据在本层的存储中找到。
  - **失效【miss】**：处理器所需的数据不在本层的存储中，将访问下一级存储。
  - **命中率**：在访问某个存储器层次时命中的次数占总访问次数的比例。
  - **失效率**：在访问某个存储器层次时失效的次数占总访问次数的比例。
  - **命中时间**：访问某个存储器层次所需要的时间，包括判断命中或失效的时间。
  - **失效损伤**：将数据块从下层存储复制到某层所需的时间，包括数据块的访问时间、传输时间、写入目标层的时间和将数据块返回给请求的时间。

## 存储器技术

| 存储器技术           | 典型访问时间【ns】 | 2012年每GiB的价格【美元】 |
| -------------------- | ------------------ | ------------------------- |
| SRAM【静态随机存取】 | 0.5 ~ 2.5          | 500 ~ 1000                |
| DRAM【动态随机存取】 | 50 ~ 70            | 10 ~ 20                   |
| Flash                | 5000 ~ 50000       | 0.75 ~ 1.00               |
| 磁盘                 | 5000000 ~ 20000000 | 0.05 ~ 0.10               |

- **SRAM**：是一种组织成存储阵列结构的简单集成电路，一个存储单元通常由 6 ~ 8 个晶体管组成，但当今处理器芯片集成了多层次cache，因此 SRAM 芯片几乎消失了。

- **DRAM**：使用电容保存电荷的方式来存储数据。

  > - 由于电容会漏电，因此必须周期性刷新，所以是动态存储。
  > - 译码器使用行列地址。如果用单译码器，选通线很多。工程难度大。
  > - **刷新**
  >   - 频率：2ms。
  >   - 每次刷新：以行为单位，每次刷新一行。
  >   - 刷新方式：读出一行再重新写入。
  >   - **刷新方式**
  >     - **分散刷新**：对每行的刷新分散到各个工作周期中，每个工作周期前半部分用于正常读写，后半部分用于刷新一行。
  >     - **集中刷新**：利用一段固定时间，依次对存储器的所有行进行逐一再生，存储周期不变，在刷新时间内停止对存储器的访问，称为死时间。
  >     - **异步刷新**：避免cpu连续等待过长时间，每隔一段周期刷新一行。

- **闪存**：电可擦除的可编程只读存储器。

  > 写操作会使存储位损耗，由控制器将写入很多次的块写入次数较少的块，称为损耗均衡。

- **磁盘**

  - **磁道**：位于磁盘表面的数万个同心圆环中的任意一个圆环称为一个磁道。
  - **扇区**：构成磁盘上磁道的基本单位，是磁盘上数据读写的最小单位。
  - **寻道**：把读写磁头移动到磁盘上适当的磁道上面的过程。

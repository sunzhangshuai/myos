# 第四章

**程序  `process-run.py` ，允许查看进程状态在 CPU 上运行时的变化情况**。

1. 用以下标志运行程序：`-l 5:100,5:100`。CPU 利用率（CPU 使用时间的百分比）应该是多少？为什么你知道这一点？利用 `-c` 标记查看你的答案是否正确。

   > 答：CPU 利用率为 100%,程序没有进行 IO。
   >
   > 验证：`./src/process-run.py -l 5:100,5:100 -c`。

2. 现在用这些标志运行： `-l 4:100,1:0` 这些标志指定了一个包含 4 条指令的进程(都要使用 CPU)，并且只是简单地发出 IO 并等待它完成。完成这两个进程需要多长时间?利用 `-c` 检查你的答案是否正确。

   > 答：需要 10 个时钟周期，因为io需要等待5。
   >
   > 验证：`./src/process-run.py -l 4:100,1:0 -c`。

3. 现在交换进程的顺序： `./src/process-run.py -l 1:0,4:100` 现在发生了什么？交换顺序是否重要？为什么？同样，用 `-c` 看看你的答案是否正确。

   > 答：进程 1 （PID1）执行 IO 时,进程 2 使用 CPU，运行时间由 10 变为 6 个时钟周期。
   >
   > 验证：`./src/process-run.py -l 1:0,4:100 -c`。

4. 现在探索另一些标志。一个重要的标志是 -S，它决定了当进程发出 IO 时系统如何反应。将标志设置为 SWITCH_ON_END，在进程进行 I/O 操作时,系统将不会切换到另一个进程,而是等待进程完成。当你运行以下两个进程时，会发生什么情况？一个执行 I/O，另一个执行 CPU 工作。（`-l 1:0,4:100 -c -S SWITCH_ON_END`）

   > 答：进程 1 执行 IO 操作时，进程 2 等待。
   >
   > 验证：`./src/process-run.py -l 1:0,4:100 -c -S SWITCH_ON_END -c`。

5. 现在,运行相同的进程，但切换行为设置，在等待 IO 时切换到另一个进程（`-l 1:0,4:100 -c -S SWITCH_ON_IO`）现在会发生什么？利用 -c 来确认你的答案是否正确。

   > 答：进程 1 执行 IO 操作时，进程 2 执行,充分利用 CPU 资源。
   >
   > 验证：`./src/process-run.py -l 1:0,4:100 -c -S SWITCH_ON_IO`。

6. 另一个重要的行为是 IO 完成时要做什么。利用 `-I IO_RUN_LATER`，当 IO 完成时,发出它的进程不一定马上运行。相反，当时运行的进程一直运行。当你运行这个进程组合时会发生什么？（`-l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p`）系统资源是否被有效利用？

   > 答：系统资源没有被有效利用，cpu 使用率59.09%。
   >
   > 验证：`./src/process-run.py -l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_LATER -c -p`。

7. 现在运行相同的进程,但使用 `-I IO_RUN_IMMEDIATE` 设置,该设置立即运行发出 IO 的进程。这种行为有何不同？为什么运行一个刚刚完成 IO 的进程会是一个好主意？

   > 答： 系统资源被有效利用，当 IO 密集进程 IO 完毕时，立即切换到该进程发出 IO 操作请求，再让出 cpu，使得系统资源被充分利用。
   >
   > 验证：`./src/process-run.py -l 3:0,5:100,5:100 -S SWITCH_ON_IO -I IO_RUN_IMMEDIATE -c -p`。

8. 现在运行一些随机生成的进程,例如 `-s 1 -l 3:50,3:50，-s 2 -l 3:50,3:50，-s 3 -l 3:50,3:50` 看看你是否能预测追踪记录会如何变化？当你使用 `-I IO_RUN_IMMEDIATE` 与 `-I IO_RUN_LATER` 时会发生什么？当你使用 `-S SWITCH_ON_IO` 与 `-S SWITCH_ON_END` 时会发生什么?

   > ```shell
   > ./src/process-run.py -s 1 -l 3:50,3:50 -c -I IO_RUN_IMMEDIATE -S SWITCH_ON_IO
   > ./src/process-run.py -s 2 -l 3:50,3:50 -c -I IO_RUN_IMMEDIATE -S SWITCH_ON_IO
   > ./src/process-run.py -s 3 -l 3:50,3:50 -c -I IO_RUN_IMMEDIATE -S SWITCH_ON_IO
   > ```

# 第五章

1. 编写一个调用 fork()的程序。在调用之前,让主进程访问一个变量(例如 x)并将其值设置为某个值(例如 100)。子进程中的变量有什么值?当子进程和父进程都改变 x 的值时,变量会发生什么?

   > 答: 子进程父进程各自一份 x 变量,修改互不影响。
   >
   > 验证：`./ch5/task1`

2. 编写一个打开文件的程序(使用 open 系统调用),然后调用 fork 创建一个新进程。子进程和父进程都可以访问 open()返回的文件描述符吗?当它们并发(即同时)写入文件时,会发生什么?

   > 答: 子进程和父进程都能访问 fd。存在竞争条件，无法同时使用 fd，但最终都会写入成功。
   >
   > 验证：`./ch5/task2`

3. 使用 fork()编写另一个程序。子进程应打印“hello”,父进程应打印“goodbye”你应该尝试确保子进程始终先打印。你能否不在父进程调用 wait()而做到这一点呢?

   > 答：vfork能保证子进程先执行。不过已经弃用了。

4. 编写一个调用 fork()的程序,然后调用某种形式的 exec()来运行程序"/bin/ls"看看是否可以尝试 exec 的所有变体,包括 execl()、 execle()、 execlp()、 execv()、 execvp()和 execve(),为什么同样的基本调用会有这么多变种？

   > exec 多个变体提供不同的功能。
   >
   > 在 exec 函数族中，后缀 l、v、p、e 添加到 exec 后，所指定的函数将具有某种操作能力：
   >
   > - l: 希望接收以逗号分隔的参数列表,列表以 NULL 指针作为结束标志
   > - v: 希望接收一个以 NULL 结尾字符串数组的指针
   > - p: 是一个以 NULL 结尾的字符串数组指针,函数可以利用 DOS 的 PATH 变量查找自程序文件
   > - e 函数传递指定采纳数 envp(环境变量),允许改变子进程环境,无后缀 e 是,子进程使用当前程序环境
   >
   > c 语言没有默认参数语法,只能实现多个变体。

5. 现在编写一个程序，在父进程中使用 wait(),等待子进程完成。wait()返回什么？如果你在子进程中使用 wait()会发生什么？

   > 答: wait 成功返回子进程 id,执行失败返回-1
   >
   > 子进程调用 wait,执行失败,返回-1。

6. 对前一个程序稍作修改，这次使用 waitpid()而不是 wait()。什么时候 waitpid()会有用？

   > 答: waitpid 提供更多操作,比如提供非阻塞版本 wait。

7. 编写一个创建子进程的程序，然后在子进程中关闭标准输出（STDOUT_FILENO).如果子进程在关闭描述符后调用 printf()打印输出，会发生什么？

   > printf 不会打印到控制台。

8. 编写一个程序，创建两个子进程，并使用 pipe()系统调用，将一个子进程的标准输出连接到另一个子进程的标准输入。

   > 验证：`./ch5/task8`

# 第六章

测量系统调用和上下文切换的成本。

- **系统调用**

  > `./ch6/syscall`。

- **上下文切换**

  > `./ch6/contentswitch`。

# 第七章
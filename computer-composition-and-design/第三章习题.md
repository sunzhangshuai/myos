1. `5ED4 - 07A4` 是无符号16位十六进制数时如何表示？结果必须使用16进制表示。

   > A = 10, B = 11, C = 12, D = 13, E = 14, F = 15
   >
   > 答：5730

2. `5ED4 - 07A4` 是带符号16位十六进制数且以符号 - 数值形式存放时如何表示？结果必须使用16进制表示。

   > 答：5730

3. 将 `5ED4` 转换成二进制数。

   > 答：0101111000110100

4. 写出 `4365 - 3412` 使用无符号12位八进制数的表示形式。结果必须使用八进制表示。

   > 答：753

5. 写出 `4365 - 3412` 使用带符号12位十六进制数且以符号 - 数值形式存放的表示形式。结果必须使用八进制表示。

   > 4365：100011110101  是负数
   >
   > 3412：011100001010；负数减正数为两值相加。
   >
   > 相加：符号位都为负，不变。和为：111111111111
   >
   > 答：-3777

6. 假定 `185` 和 `122` 是无符号8位十进制整数。计算 `185 - 122`。是否有上溢或者下溢？

   > 答：63。
   >
   > 8位最大值是255，不会溢出。

7. 假定 `185` 和 `122` 是带符号8位十进制整数且以符号 - 数值形式存放。计算 `185 + 122`。是否有上溢或者下溢？

   > 185：10111001，负数
   >
   > 122：01111010，正数
   >
   > 相加：122绝对值比185大，符号为正，差为：1000001，最终为 01000101
   >
   > 答：65。无溢出。

8. 假定 `185` 和 `122` 是带符号8位十进制整数且以符号 - 数值形式存放。计算 `185 - 122`。是否有上溢或者下溢？

   > 负数减正数，相加。有溢出，10110011。
   >
   > 答：179。

9. 假定 `151` 和 `214` 是带符号8位十进制整数且以补码形式存放。使用饱和算数计算 `151 + 214`。结果必须使用十进制。

   > 151：10010111  
   >
   > 214：11010110
   >
   > 答：相加发生溢出，所以值应为负数最小值，-128。

10. 假定 `151` 和 `214` 是带符号8位十进制整数且以补码形式存放。使用饱和算数计算 `151 - 214`。结果必须使用十进制。

    > 151：10010111  
    >
    > 214：11010110  原码：00101010
    >
    > 答：11000001，原码：00111111，值为-63。

11. 假定 `151` 和 `214` 是无符号8位十进制整数。使用饱和算数计算 `151 - 214`。结果必须使用十进制。

    > 答：发生溢出，值为最大数，即255。

12. 使用图 3-3 所示的硬件描述计算八进制无符号6位整数 `62 * 12`，并给出一个类似于图 3-6 中的表。必须给出每个步骤中每个寄存器的内容。

    > | 迭代次数 | 步骤                     | 乘数    | 被乘数          | 乘积            |
    > | -------- | ------------------------ | ------- | --------------- | --------------- |
    > | 0        | 初始值                   | 001 010 | 000 000 110 010 | 000 000 000 000 |
    > | 1        | 乘数末位0：无操作        | 001 010 | 000 000 110 010 | 000 000 000 000 |
    > |          | 被乘数左移一位           | 001 010 | 000 001 100 100 | 000 000 000 000 |
    > |          | 乘数右移一位             | 000 101 | 000 001 100 100 | 000 000 000 000 |
    > | 2        | 乘数末位1：乘积 + 被乘数 | 000 101 | 000 001 100 100 | 000 001 100 100 |
    > |          | 被乘数左移一位           | 000 101 | 000 011 001 000 | 000 001 100 100 |
    > |          | 乘数右移一位             | 000 010 | 000 011 001 000 | 000 001 100 100 |
    > | 3        | 乘数末位0：无操作        | 000 010 | 000 011 001 000 | 000 001 100 100 |
    > |          | 被乘数左移一位           | 000 010 | 000 110 010 000 | 000 001 100 100 |
    > |          | 乘数右移一位             | 000 001 | 000 110 010 000 | 000 001 100 100 |
    > | 4        | 乘数末位1：乘积 + 被乘数 | 000 001 | 000 110 010 000 | 000 111 110 100 |
    > |          | 被乘数左移一位           | 000 001 | 001 100 100 000 | 000 111 110 100 |
    > |          | 乘数右移一位             | 000 000 | 001 100 100 000 | 000 111 110 100 |
    > | 5        | 乘数末位0：无操作        | 000 000 | 001 100 100 000 | 000 111 110 100 |
    > |          | 被乘数左移一位           | 000 000 | 011 001 000 000 | 000 111 110 100 |
    > |          | 乘数右移一位             | 000 000 | 011 001 000 000 | 000 111 110 100 |
    > | 6        | 乘数末位0：无操作        | 000 000 | 011 001 000 000 | 000 111 110 100 |
    > |          | 被乘数左移一位           | 000 000 | 110 010 000 000 | 000 111 110 100 |
    > |          | 乘数右移一位             | 000 000 | 110 010 000 000 | 000 111 110 100 |
    >
    > 答：值为500。

13. 使用与图 3-6 相同的一张表，使用图3-5所示的硬件描述计算十六进制无符号8位整数 `62 * 12` 。必须给出每个步骤中每个寄存器的内容。

    > | 迭代次数 | 步骤                         | 被乘数    | 乘数/乘积           |
    > | -------- | ---------------------------- | --------- | ------------------- |
    > | 0        | 初始值                       | 0110 0010 | 0000 0000 0001 0010 |
    > | 1        | 乘数末位0：无操作            | 0110 0010 | 0000 0000 0001 0010 |
    > |          | 乘数右移一位                 | 0110 0010 | 0000 0000 0000 1001 |
    > | 2        | 乘数末位1：乘积高位 + 被乘数 | 0110 0010 | 0110 0010 0000 1001 |
    > |          | 乘数右移一位                 | 0110 0010 | 0011 0001 0000 0100 |
    > | 3        | 乘数末位0：无操作            | 0110 0010 | 0011 0001 0000 0100 |
    > |          | 乘数右移一位                 | 0110 0010 | 0001 1000 1000 0010 |
    > | 4        | 乘数末位0：无操作            | 0110 0010 | 0001 1000 1000 0010 |
    > |          | 乘数右移一位                 | 0110 0010 | 0000 1100 0100 0001 |
    > | 5        | 乘数末位1：乘积高位 + 被乘数 | 0110 0010 | 0110 1110 0100 0001 |
    > |          | 乘数右移一位                 | 0110 0010 | 0011 0111 0010 0000 |
    > | 6        | 乘数末位0：无操作            | 0110 0010 | 0011 0111 0010 0000 |
    > |          | 乘数右移一位                 | 0110 0010 | 0001 1011 1001 0000 |
    > | 7        | 乘数末位0：无操作            | 0110 0010 | 0001 1011 1001 0000 |
    > |          | 乘数右移一位                 | 0110 0010 | 0000 1101 1100 1000 |
    > | 8        | 乘数末位0：无操作            | 0110 0010 | 0000 1101 1100 1000 |
    > |          | 乘数右移一位                 | 0110 0010 | 0000 0110 1110 0100 |
    >
    > 答：1764溢出了，应该取后8位，即228。

14. 如果一个整数是8位宽，且每个步骤的操作需要4个时间单位，使用图 3-3 和图 3-4 的方法计算执行一次乘法必需的时间。假定在步骤`1a` 中，无论是否加了被乘数还是加0，加法都要执行。另外假设寄存器已经初始化（只需要计算执行乘法循环本身所需要的时间）。如果是在硬件中执行，对被乘数和乘数的移位可以同时进行；如果是在软件中执行，则会做完再做下一个。对每种情况都给出解答。

    > 答：
    >
    > - 硬件：2 * 8 * 4 = 64
    > - 软件：3 * 8 * 4 = 96

15. 计算采用书中的方法（31个垂直的加法栈堆）来执行乘法所需的时间。设整数位宽是8，一个加法需4个时间单位。

    > 答：加法器栈是上一次的计算结果作为下一次的输入，所以是 (8 - 1) * 4 = 28。

16. 计算采用图 3-7 中的方法来执行乘法所需的时间，设整数位宽是8，一个加法需要4个时间单位。

    > 答：图 3-7 是并行树，所以是 log₂(8) * 4 = 12。

17. 正如书中讨论的，一种增强性能的办法是做一次移位和加法来代替一次实际的乘法。例如，因为 `9 * 6` 可以写成 `(2 * 2 * 2 + 1) * 6`, 所以可以通过将6左移3次再加上6来计算 `9 * 6`。请给出用移位和加/减法来计算 `0x33 * 0x55` 的最好的方法。假设输入都是8位无符号整数。

    > 0x33 = 51 = 32 + 16 + 2 + 1
    >
    > 0x55 = 85 = 64 + 16 + 4 + 1
    >
    > 答：移3次，加3次。

18. 使用图 3-8 中的硬件结构计算 `74/21`，并给出一个类似于图 3-10 中的表。需要每一步各个寄存器的值。假设输入是6位无符号整数。

    > | 迭代次数 | 步骤                               | 商      | 除数            | 余数            |
    > | -------- | ---------------------------------- | ------- | --------------- | --------------- |
    > | 0        | 初始值                             | 000 000 | 010 001 000 000 | 000 000 111 100 |
    > | 1        | 余数 = 余数 - 除数                 | 000 000 | 010 001 000 000 | 101 111 111 100 |
    > |          | 余数 < 0，+除数，商左移，最低位上0 | 000 000 | 010 001 000 000 | 000 000 111 100 |
    > |          | 除数右移                           | 000 000 | 001 000 100 000 | 000 000 111 100 |
    > | 2        | 余数 = 余数 - 除数                 | 000 000 | 001 000 100 000 | 111 000 011 100 |
    > |          | 余数 < 0，+除数，商左移，最低位上0 | 000 000 | 001 000 100 000 | 000 000 111 100 |
    > |          | 除数右移                           | 000 000 | 000 100 010 000 | 000 000 111 100 |
    > | 3        | 余数 = 余数 - 除数                 | 000 000 | 000 100 010 000 | 111 100 101 100 |
    > |          | 余数 < 0，+除数，商左移，最低位上0 | 000 000 | 000 100 010 000 | 000 000 111 100 |
    > |          | 除数右移                           | 000 000 | 000 010 001 000 | 000 000 111 100 |
    > | 4        | 余数 = 余数 - 除数                 | 000 000 | 000 010 001 000 | 111 111 110 100 |
    > |          | 余数 < 0，+除数，商左移，最低位上0 | 000 000 | 000 010 001 000 | 000 000 111 100 |
    > |          | 除数右移                           | 000 000 | 000 001 000 100 | 000 000 111 100 |
    > | 5        | 余数 = 余数 - 除数                 | 000 000 | 000 001 000 100 | 111 111 111 100 |
    > |          | 余数 < 0，+除数，商左移，最低位上0 | 000 000 | 000 001 000 100 | 000 000 111 100 |
    > |          | 除数右移                           | 000 000 | 000 000 100 010 | 000 000 111 100 |
    > | 6        | 余数 = 余数 - 除数                 | 000 000 | 000 000 100 010 | 000 000 011 010 |
    > |          | 余数 >= 0，商左移，最低位上1       | 000 001 | 000 000 100 010 | 000 000 011 010 |
    > |          | 除数右移                           | 000 001 | 000 000 010 001 | 000 000 011 010 |
    > | 7        | 余数 = 余数 - 除数                 | 000 000 | 000 000 010 001 | 000 000 001 001 |
    > |          | 余数 >= 0，商左移，最低位上1       | 000 011 | 000 000 010 001 | 000 000 001 001 |
    > |          | 除数右移                           | 000 011 | 000 000 001 000 | 000 000 001 001 |
    >
    > 答：商3，余9。

19. 使用图 3-9 中的硬件结构计算 `74/21`，并给出一个类似于图 3-10 中的表。需要每一步各个寄存器的值。假设输入是6位无符号整数。

    > | 迭代次数 | 步骤                       | 除数    | 商/余数          |
    > | -------- | -------------------------- | ------- | ---------------- |
    > | 0        | 初始化                     | 010 001 | 000 000 111 100  |
    > | 1        | 商左移                     | 010 001 | 000 001 111 000  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 110 000 111 000  |
    > |          | 余数 < 0，+除数            | 010 001 | 000 001 111 000  |
    > | 2        | 商左移                     | 010 001 | 000 011 110 000  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 110 010 110 000  |
    > |          | 余数 < 0，+除数            | 010 001 | 000 011 110 000  |
    > | 3        | 商左移                     | 010 001 | 000 111 100 000  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 110 100 100 1000 |
    > |          | 余数 < 0，+除数            | 010 001 | 000 111 100 000  |
    > | 4        | 商左移                     | 010 001 | 001 111 000 000  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 111 110 000 000  |
    > |          | 余数 < 0，+除数            | 010 001 | 001 111 000 000  |
    > | 5        | 商左移                     | 010 001 | 011 110 000 000  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 001 111 000 000  |
    > |          | 余数 >= 0，商末位补1       | 010 001 | 001 111 000 001  |
    > | 6        | 商左移                     | 010 001 | 011 110 000 010  |
    > |          | 余数 = 余数【高位】 - 除数 | 010 001 | 001 001 000 010  |
    > |          | 余数 >= 0，商末位补1       | 010 001 | 001 001 000 011  |
    >
    > 答：商3，余9。

20. 如果是补码整数，则这些位模式 `0x0C000000` 代表的十进制是多少？如果无符号整数呢？

    > 答：2<sup>26</sup>  + 2<sup>27</sup> =  201326592。

21. 如果位模式存 `0x0C000000` 放在指令寄存器中，将执行什么MIPS指令？

    > 答：书上第79页显示 000 011 对应的指令是 跳转并链接，高位是PC前6位，未知，地址全为0，即 jal 0x00000000。

22. 如果是浮点数，位模式存 `0x0C000000` 代表的十进制数是多少？使用 IEEE. 754标准。

    > 00001100 00000000 00000000 00000000
    >
    > 符号正，指数为 24 - 127 = -103，值为2<sup>-103</sup>。

23. 写出10进制数 63.25 的二进制表达，单精度格式。

    > 63.25  = 11 1111.01 = 1.1111101 * 2<sup>5</sup>
    >
    > 5 + 127 = 132
    >
    > 答：0 10000010 11111010000000000000000 即 0x427D0000。

24. 写出10进制数 63.25 的二进制表达，双精度格式。

    > 1023 + 5 = 1028
    >
    > 答：0 10000000010 1111101000000000000000000000000000000000000000000000 即 0x404FA00000000000。

25. 写出10进制数 63.25 的二进制表达，IBM 单精度格式。【基数为16，指数位7个】

    > 答： 0 1000010 001111110100000000000000